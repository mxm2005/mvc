<?php


/**
*
*/
class Minifier
{

	public static function parse($file,$debug=false,$ver=null,$project=null)
	{
		$cacheDir=sys_get_temp_dir();
		$options=['compress'=>!$debug,'cache_dir'=>$cacheDir];
		$variables=['ver'=>$ver,'project'=>$project];
		$lessFiles=[];
		if(is_array($file))
		{
			foreach ($file as $f)
			{
				$lessFiles[$f]=null;
			}
		}
		else
		{
			$lessFiles=[$file];
		}
		$cssFileName=Less_Cache::Get($lessFiles,$options,$variables);
		return file_get_contents($cacheDir.DIRECTORY_SEPARATOR.$cssFileName);
	}

	public static function minify($file,$debug=false,$ver=null,$project=null)
	{
		$content=self::getContent($file);
		if(!$content||$debug)
		{
			return $content;
		}
		$minify=new JSqueeze();
		return $minify->squeeze($content,true,false,false);
	}

	private static function getContent($file)
	{
		$contents=[];
		if(is_array($file))
		{
			foreach ($file as $f)
			{
				if(is_file($f)&&is_readable($f))
				{
					$contents[]=file_get_contents($f);
				}
				else
				{
					throw new Exception("Can not load file {$f}",404);
				}
			}
			return trim(implode(PHP_EOL,$contents));
		}
		return trim($file);
	}
}

class JSqueeze { const SPECIAL_VAR_PACKER = '(\$+[a-zA-Z_]|_[a-zA-Z0-9$])[a-zA-Z0-9_$]*'; public $charFreq; protected $strings, $closures, $str0, $str1, $argFreq, $specialVarRx, $keepImportantComments, $varRx = '(?:[a-zA-Z_$])[a-zA-Z0-9_$]*', $reserved = array( 'true','false','null', 'break','case','class','catch','const','continue','debugger','default','delete','do','else','export','extends','finally','for','function','if','import','in','instanceof','new','return','super','switch','this','throw','try','typeof','var','void','while','with','yield', 'enum', 'implements','package','protected','static','let','interface','private','public', 'await', 'abstract','boolean','byte','char','double','final','float','goto','int','long','native','short','synchronized','throws','transient','volatile', ); function __construct() { $this->reserved = array_flip($this->reserved); $this->charFreq = array_fill(0, 256, 0); } function squeeze($code, $singleLine = true, $keepImportantComments = true, $specialVarRx = false) { $code = trim($code); if ('' === $code) return ''; $this->argFreq = array(-1 => 0); $this->specialVarRx = $specialVarRx; $this->keepImportantComments = !!$keepImportantComments; if (preg_match("#//[ \t]*jsqueeze\.specialVarRx[ \t]*=[ \t]*([\"']?)(.*)\1#i", $code, $key)) { if (!$key[1]) { $key[2] = trim($key[2]); $key[1] = strtolower($key[2]); $key[1] = $key[1] && $key[1] != 'false' && $key[1] != 'none' && $key[1] != 'off'; } $this->specialVarRx = $key[1] ? $key[2] : false; } $this->specialVarRx && $this->specialVarRx = preg_replace('/(?<!\\\\)((?:\\\\\\\\)*)\((?!\?)/', '(?:', $this->specialVarRx); false !== strpos($code, "\r" ) && $code = strtr(str_replace("\r\n", "\n", $code), "\r", "\n"); false !== strpos($code, "\xC2\x85" ) && $code = str_replace("\xC2\x85" , "\n", $code); false !== strpos($code, "\xE2\x80\xA8") && $code = str_replace("\xE2\x80\xA8", "\n", $code); false !== strpos($code, "\xE2\x80\xA9") && $code = str_replace("\xE2\x80\xA9", "\n", $code); list($code, $this->strings ) = $this->extractStrings( $code); list($code, $this->closures) = $this->extractClosures($code); $key = "//''\"\"#0'"; $this->closures[$key] =& $code; $tree = array($key => array('parent' => false)); $this->makeVars($code, $tree[$key], $key); $this->renameVars($tree[$key], true); $code = substr($tree[$key]['code'], 1); $code = preg_replace("'\breturn !'", 'return!', $code); $code = preg_replace("'\}(?=(else|while)[^\$.a-zA-Z0-9_])'", "}\r", $code); $code = str_replace(array_keys($this->strings), array_values($this->strings), $code); if ($singleLine) $code = strtr($code, "\n", ';'); else $code = str_replace("\n", ";\n", $code); false !== strpos($code, "\r") && $code = strtr(trim($code), "\r", "\n"); $this->charFreq = array_fill(0, 256, 0); $this->strings = $this->closures = $this->argFreq = array(); $this->str0 = $this->str1 = ''; return $code; } protected function extractStrings($f) { if ($cc_on = false !== strpos($f, '@cc_on')) { $f = str_replace('#', '##', $f); $f = str_replace('/*@', '1#@', $f); $f = preg_replace("'//@([^\n]+)'", '2#@$1@#3', $f); $f = str_replace('@*/', '@#1', $f); } $len = strlen($f); $code = str_repeat(' ', $len); $j = 0; $strings = array(); $K = 0; $instr = false; $q = array( "'", '"', "'" => 0, '"' => 0, ); for ($i = 0; $i < $len; ++$i) { if ($instr) { if ('//' == $instr) { if ("\n" == $f[$i]) { $f[$i--] = ' '; $instr = false; } } else if ($f[$i] == $instr || ('/' == $f[$i] && "/'" == $instr)) { if ('!' == $instr) ; else if ('*' == $instr) { if ('/' == $f[$i+1]) { ++$i; $instr = false; } } else { if ("/'" == $instr) { while (isset ($f[$i+1]) && false !== strpos('gmi', $f[$i+1])) $s[] = $f[$i++]; $s[] = $f[$i]; } $instr = false; } } else if ('*' == $instr) ; else if ('!' == $instr) { if ('*' == $f[$i] && '/' == $f[$i+1]) { $s[] = "*/\r"; ++$i; $instr = false; } else if ("\n" == $f[$i]) $s[] = "\r"; else $s[] = $f[$i]; } else if ('\\' == $f[$i]) { ++$i; if ("\n" != $f[$i]) { isset($q[$f[$i]]) && ++$q[$f[$i]]; $s[] = '\\' . $f[$i]; } } else if ('[' == $f[$i] && "/'" == $instr) { $instr = '/['; $s[] = '['; } else if (']' == $f[$i] && '/[' == $instr) { $instr = "/'"; $s[] = ']'; } else if ("'" == $f[$i] || '"' == $f[$i]) { ++$q[$f[$i]]; $s[] = '\\' . $f[$i]; } else $s[] = $f[$i]; } else switch ($f[$i]) { case ';': if ($i>0 && ';' == $f[$i-1] && $i+1 < $len && ';' == $f[$i+1]) $f[$i] = $f[$i+1] = '/'; else { $code[++$j] = ';'; break; } case '/': if ('*' == $f[$i+1]) { ++$i; $instr = '*'; if ($this->keepImportantComments && '!' == $f[$i+1]) { ++$i; } else break; } else if ('/' == $f[$i+1]) { ++$i; $instr = '//'; break; } else { $a = $j && (' ' == $code[$j] || "\x7F" == $code[$j]) ? $code[$j-1] : $code[$j]; if (false !== strpos('-!%&;<=>~:^+|,()*?[{} ', $a) || (false !== strpos('oenfd', $a) && preg_match( "'(?<![\$.a-zA-Z0-9_])(do|else|return|typeof|yield[ \x7F]?\*?)[ \x7F]?$'", substr($code, $j-7, 8) ))) { if (')' === $a && $j > 1) { $a = 1; $k = $j - (' ' == $code[$j] || "\x7F" == $code[$j]) - 1; while ($k >= 0 && $a) { if ('(' === $code[$k]) --$a; else if (')' === $code[$k]) ++$a; --$k; } if (!preg_match("'(?<![\$.a-zA-Z0-9_])(if|for|while)[ \x7F]?$'", substr($code, 0, $k+1))) { $code[++$j] = '/'; break; } } $key = "//''\"\"" . $K++ . $instr = "/'"; $a = $j; $code .= $key; while (isset($key[++$j-$a-1])) $code[$j] = $key[$j-$a-1]; --$j; isset($s) && ($s = implode('', $s)) && $cc_on && $this->restoreCc($s); $strings[$key] = array('/'); $s =& $strings[$key]; } else $code[++$j] = '/'; break; } case "'": case '"': $instr = $f[$i]; $key = "//''\"\"" . $K++ . ('!' == $instr ? ']' : "'"); $a = $j; $code .= $key; while (isset($key[++$j-$a-1])) $code[$j] = $key[$j-$a-1]; --$j; isset($s) && ($s = implode('', $s)) && $cc_on && $this->restoreCc($s); $strings[$key] = array(); $s =& $strings[$key]; '!' == $instr && $s[] = "\r/*!"; break; case "\n": if ($j > 3) { if (' ' == $code[$j] || "\x7F" == $code[$j]) --$j; $code[++$j] = false !== strpos('kend+-', $code[$j-1]) && preg_match( "'(?:\+\+|--|(?<![\$.a-zA-Z0-9_])(break|continue|return|yield[ \x7F]?\*?))[ \x7F]?$'", substr($code, $j-8, 9) ) ? ';' : "\x7F"; break; } case "\t": $f[$i] = ' '; case ' ': if (!$j || ' ' == $code[$j] || "\x7F" == $code[$j]) break; default: $code[++$j] = $f[$i]; } } isset($s) && ($s = implode('', $s)) && $cc_on && $this->restoreCc($s); unset($s); $code = substr($code, 0, $j+1); $cc_on && $this->restoreCc($code, false); $code = strtr($code, "\x7F", ' '); $code = str_replace('- -', "-\x7F-", $code); $code = str_replace('+ +', "+\x7F+", $code); $code = str_replace('get ', "get\x7F", $code); $code = str_replace('set ', "set\x7F", $code); $code = preg_replace("'(\d)\s+\.\s*([a-zA-Z\$_[(])'", "$1\x7F.$2", $code); $code = preg_replace("# ([-!%&;<=>~:.^+|,()*?[\]{}/']+)#", '$1', $code); $code = preg_replace( "#([-!%&;<=>~:.^+|,()*?[\]{}/]+) #", '$1', $code); $cc_on && $code = preg_replace_callback("'//[^\'].*?@#3'", function ($m) {return strtr($m[0], ' ', "\x7F");}, $code); false !== strpos($code, 'new Array' ) && $code = preg_replace( "'new Array(?:\(\)|([;\])},:]))'", '[]$1', $code); false !== strpos($code, 'new Object') && $code = preg_replace("'new Object(?:\(\)|([;\])},:]))'", '{}$1', $code); $code = preg_replace("'\}(?![:,;.()\[\]}\|&]|(else|catch|finally|while)[^\$.a-zA-Z0-9_])'", '};', $code); $code = preg_replace("'(?<![\$.a-zA-Z0-9_])if\('" , '1#(', $code); $code = preg_replace("'(?<![\$.a-zA-Z0-9_])for\('" , '2#(', $code); $code = preg_replace("'(?<![\$.a-zA-Z0-9_])while\('", '3#(', $code); $forPool = array(); $instrPool = array(); $s = 0; $f = array(); $j = -1; $len = strlen($code); for ($i = 0; $i < $len; ++$i) { switch ($code[$i]) { case '(': if ($j>=0 && "\n" == $f[$j]) $f[$j] = ';'; ++$s; if ($i && '#' == $code[$i-1]) { $instrPool[$s - 1] = 1; if ('2' == $code[$i-2]) $forPool[$s] = 1; } $f[++$j] = '('; break; case ']': case ')': if ($i+1 < $len && !isset($forPool[$s]) && !isset($instrPool[$s-1]) && preg_match("'[a-zA-Z0-9_\$]'", $code[$i+1])) { $f[$j] .= $code[$i]; $f[++$j] = "\n"; } else $f[++$j] = $code[$i]; if (')' == $code[$i]) { unset($forPool[$s]); --$s; } continue 2; case '}': if ("\n" == $f[$j]) $f[$j] = '}'; else $f[++$j] = '}'; break; case ';': if (isset($forPool[$s]) || isset($instrPool[$s])) $f[++$j] = ';'; else if ($j>=0 && "\n" != $f[$j] && ';' != $f[$j]) $f[++$j] = "\n"; break; case '#': switch ($f[$j]) { case '1': $f[$j] = 'if'; break 2; case '2': $f[$j] = 'for'; break 2; case '3': $f[$j] = 'while'; break 2; } case '['; if ($j>=0 && "\n" == $f[$j]) $f[$j] = ';'; default: $f[++$j] = $code[$i]; } unset($instrPool[$s]); } $f = implode('', $f); $cc_on && $f = str_replace('@#3', "\r", $f); $f = preg_replace("'(?<![\$.a-zA-Z0-9_])else\n'", "\n", $f); $r1 = array( 'case','delete','do','else','function','in','instanceof','of','break', 'new','return','throw','typeof','var','void','yield','let','if', 'const', ); $r2 = array( 'in','instanceof','of', ); $f = preg_replace("'(?<!(?<![a-zA-Z0-9_\$])" . implode(')(?<!(?<![a-zA-Z0-9_\$])', $r1) . ") (?!(" . implode('|', $r2) . ")(?![a-zA-Z0-9_\$]))'", "\n", $f); $f = preg_replace("'(?<!(?<![a-zA-Z0-9_\$])do)(?<!(?<![a-zA-Z0-9_\$])else) if\('", "\nif(", $f); $f = preg_replace("'(?<=--|\+\+)(?<![a-zA-Z0-9_\$])(" . implode('|', $r1) . ")(?![a-zA-Z0-9_\$])'", "\n$1", $f); $f = preg_replace("'(?<![a-zA-Z0-9_\$])for\neach\('", 'for each(', $f); $f = preg_replace("'(?<![a-zA-Z0-9_\$])\n(" . implode('|', $r2) . ")(?![a-zA-Z0-9_\$])'", '$1', $f); if ($q["'"] > $q['"']) $q = array($q[1], $q[0]); $f = preg_replace("#//''\"\"[0-9]+'#", $q[0] . '$0' . $q[0], $f); strpos($f, $q[0] . '+' . $q[0]) && $f = str_replace($q[0] . '+' . $q[0], '', $f); $len = count($strings); foreach ($strings as $r1 => &$r2) { $r2 = "/'" == substr($r1, -2) ? str_replace(array("\\'", '\\"'), array("'", '"'), $r2) : str_replace('\\' . $q[1], $q[1], $r2); } $f = strtr($f, "\x7F", ' '); return array($f, $strings); } protected function extractClosures($code) { $code = ';' . $code; $this->argFreq[-1] += substr_count($code, '}catch('); if ($this->argFreq[-1]) { $f = preg_split("@}catch\(({$this->varRx})@", $code, -1, PREG_SPLIT_DELIM_CAPTURE); $code = 'catch$scope$var' . mt_rand(); $this->specialVarRx = $this->specialVarRx ? '(?:' . $this->specialVarRx . '|' . preg_quote($code) . ')' : preg_quote($code); $i = count($f) - 1; while ($i) { $c = 1; $j = 0; $l = strlen($f[$i]); while ($c && $j < $l) { $s = $f[$i][$j++]; $c += '(' == $s ? 1 : (')' == $s ? -1 : 0); } if (!$c) do { $s = $f[$i][$j++]; $c += '{' == $s ? 1 : ('}' == $s ? -1 : 0); } while ($c && $j < $l); $c = preg_quote($f[$i-1], '#'); $f[$i-2] .= '}catch(' . preg_replace("#([.,{]?)(?<![a-zA-Z0-9_\$@]){$c}\\b#", '$1' . $code, $f[$i-1] . substr($f[$i], 0, $j)) . substr($f[$i], $j); unset($f[$i--], $f[$i--]); } $code = $f[0]; } $f = preg_split("'(?<![a-zA-Z0-9_\$])(function[ (].*?\{)'", $code, -1, PREG_SPLIT_DELIM_CAPTURE); $i = count($f) - 1; $closures = array(); while ($i) { $c = 1; $j = 0; $l = strlen($f[$i]); while ($c && $j < $l) { $s = $f[$i][$j++]; $c += '{' == $s ? 1 : ('}' == $s ? -1 : 0); } switch (substr($f[$i-2], -1)) { default: if (false !== $c = strpos($f[$i-1], ' ', 8)) break; case false: case "\n": case ';': case '{': case '}': case ')': case ']': $c = strpos($f[$i-1], '(', 8); } $l = "//''\"\"#$i'"; $code = substr($f[$i-1], $c); $closures[$l] = $code . substr($f[$i], 0, $j); $f[$i-2] .= substr($f[$i-1], 0, $c) . $l . substr($f[$i], $j); if ('(){' !== $code) { $j = substr_count($code, ','); do isset($this->argFreq[$j]) ? ++$this->argFreq[$j] : $this->argFreq[$j] = 1; while ($j--); } $i -= 2; } return array($f[0], $closures); } protected function makeVars($closure, &$tree, $key) { $tree['code'] =& $closure; $tree['nfe'] = false; $tree['used'] = array(); $tree['local'] = array(); $closure = preg_replace_callback("'(?<=[\n\{\}])var [^\n\{\}]+(?:\nvar [^\n\{\}]+)+'", array(&$this, 'mergeVarDeclarations'), $closure); $vars =& $tree['local']; if (preg_match("'^( [^(]*)?\((.*?)\)\{'", $closure, $v)) { if ($v[1]) { $vars[$tree['nfe'] = substr($v[1], 1)] = -1; $tree['parent']['local'][';' . $key] =& $vars[$tree['nfe']]; } if ($v[2]) { $i = 0; $v = explode(',', $v[2]); foreach ($v as $w) $vars[$w] = $this->argFreq[$i++] - 1; } } $v = preg_split("'(?<![\$.a-zA-Z0-9_])var '", $closure); if ($i = count($v) - 1) { $w = array(); while ($i) { $j = $c = 0; $l = strlen($v[$i]); while ($j < $l) { switch ($v[$i][$j]) { case '(': case '[': case '{': ++$c; break; case ')': case ']': case '}': if ($c-- <= 0) break 2; break; case ';': case "\n": if (!$c) break 2; default: $c || $w[] = $v[$i][$j]; } ++$j; } $w[] = ','; --$i; } $v = explode(',', implode('', $w)); foreach ($v as $w) if (preg_match("'^{$this->varRx}'", $w, $v)) isset($vars[$v[0]]) || $vars[$v[0]] = 0; } if (preg_match_all("@function ({$this->varRx})//''\"\"#@", $closure, $v)) { foreach ($v[1] as $w) isset($vars[$w]) || $vars[$w] = 0; } if ($this->argFreq[-1] && preg_match_all("@}catch\(({$this->varRx})@", $closure, $v)) { $v[0] = array(); foreach ($v[1] as $w) isset($v[0][$w]) ? ++$v[0][$w] : $v[0][$w] = 1; foreach ($v[0] as $w => $v) $vars[$w] = $this->argFreq[-1] - $v; } $vars =& $tree['used']; if (preg_match_all("#([.,{]?)(?<![a-zA-Z0-9_\$])({$this->varRx})(:?)#", $closure, $w, PREG_SET_ORDER)) { foreach ($w as $k) { if (',' === $k[1] || '{' === $k[1]) { if (':' === substr($k[3], -1)) $k = '.' . $k[2]; else $k = $k[2]; } else $k = $k[1] . $k[2]; isset($vars[$k]) ? ++$vars[$k] : $vars[$k] = 1; } } if (preg_match_all("#//''\"\"[0-9]+(?:['!]|/')#", $closure, $w)) foreach ($w[0] as $a) { $v = "'" === substr($a, -1) && "/'" !== substr($a, -2) && $this->specialVarRx ? preg_split("#([.,{]?(?<![a-zA-Z0-9_\$@]){$this->specialVarRx}:?)#", $this->strings[$a], -1, PREG_SPLIT_DELIM_CAPTURE) : array($this->strings[$a]); $a = count($v); for ($i = 0; $i < $a; ++$i) { $k = $v[$i]; if (1 === $i%2) { if (',' === $k[0] || '{' === $k[0]) { if (':' === substr($k, -1)) $k = '.' . substr($k, 1, -1); else $k = substr($k, 1); } else if (':' === substr($k, -1)) $k = substr($k, 0, -1); $w =& $tree; while (isset($w['parent']) && !(isset($w['used'][$k]) || isset($w['local'][$k]))) $w =& $w['parent']; (isset($w['used'][$k]) || isset($w['local'][$k])) && (isset($vars[$k]) ? ++$vars[$k] : $vars[$k] = 1); unset($w); } if (0 === $i%2 || !isset($vars[$k])) foreach (count_chars($v[$i], 1) as $k => $w) $this->charFreq[$k] += $w; } } foreach ($vars as $w => $a) { $k =& $tree; $chain = array(); do { $vars =& $k['local']; $chain[] =& $k; if (isset($vars[$w])) { unset($k['used'][$w]); if (isset($vars[$w])) $vars[$w] += $a; else $vars[$w] = $a; $a = false; break; } } while ($k['parent'] && $k =& $k['parent']); if ($a && !$k['parent']) { if (isset($vars[$w])) $vars[$w] += $a; else $vars[$w] = $a; } if (isset($tree['used'][$w]) && isset($vars[$w])) foreach ($chain as &$b) { isset($b['local'][$w]) || $b['used'][$w] =& $vars[$w]; } } $tree['childs'] = array(); $vars =& $tree['childs']; if (preg_match_all("@//''\"\"#[0-9]+'@", $closure, $w)) { foreach ($w[0] as $a) { $vars[$a] = array('parent' => &$tree); $this->makeVars($this->closures[$a], $vars[$a], $a); } } } protected function mergeVarDeclarations($m) { return str_replace("\nvar ", ',', $m[0]); } protected function renameVars(&$tree, $root) { if ($root) { $tree['local'] += $tree['used']; $tree['used'] = array(); foreach ($tree['local'] as $k => $v) { if ('.' == $k[0]) $k = substr($k, 1); if ('true' === $k) $this->charFreq[48] += $v; else if ('false' === $k) $this->charFreq[49] += $v; else if (!$this->specialVarRx || !preg_match("#^{$this->specialVarRx}$#", $k)) { foreach (count_chars($k, 1) as $k => $w) $this->charFreq[$k] += $w * $v; } else if (2 == strlen($k)) $tree['used'][] = $k[1]; } arsort($this->charFreq); $this->str0 = ''; $this->str1 = ''; foreach ($this->charFreq as $k => $v) { if (!$v) break; $v = chr($k); if ((64 < $k && $k < 91) || (96 < $k && $k < 123)) { $this->str0 .= $v; $this->str1 .= $v; } else if (47 < $k && $k < 58) { $this->str1 .= $v; } } if ('' === $this->str0) { $this->str0 = 'claspemitdbfrugnjvhowkxqyzCLASPEMITDBFRUGNJVHOWKXQYZ'; $this->str1 = $this->str0 . '0123456789'; } foreach ($tree['local'] as $var => $root) { if ('.' != substr($var, 0, 1) && isset($tree['local'][".{$var}"])) $tree['local'][$var] += $tree['local'][".{$var}"]; } foreach ($tree['local'] as $var => $root) { if ('.' == substr($var, 0, 1) && isset($tree['local'][substr($var, 1)])) $tree['local'][$var] = $tree['local'][substr($var, 1)]; } arsort($tree['local']); foreach ($tree['local'] as $var => $root) switch (substr($var, 0, 1)) { case '.': if (!isset($tree['local'][substr($var, 1)])) { $tree['local'][$var] = '#' . ($this->specialVarRx && 3 < strlen($var) && preg_match("'^\.{$this->specialVarRx}$'", $var) ? $this->getNextName($tree) . '$' : substr($var, 1)); } break; case ';': $tree['local'][$var] = 0 === $root ? '' : $this->getNextName($tree); case '#': break; default: $root = $this->specialVarRx && 2 < strlen($var) && preg_match("'^{$this->specialVarRx}$'", $var) ? $this->getNextName($tree) . '$' : $var; $tree['local'][$var] = $root; if (isset($tree['local'][".{$var}"])) $tree['local'][".{$var}"] = '#' . $root; } foreach ($tree['local'] as $var => $root) $tree['local'][$var] = preg_replace("'^#'", '.', $tree['local'][$var]); } else { arsort($tree['local']); if (false !== $tree['nfe']) $tree['used'][] = $tree['local'][$tree['nfe']]; foreach ($tree['local'] as $var => $root) if ($tree['nfe'] !== $var) $tree['local'][$var] = 0 === $root ? '' : $this->getNextName($tree); } $this->local_tree =& $tree['local']; $this->used_tree =& $tree['used']; $tree['code'] = preg_replace_callback("#[.,{ ]?(?<![a-zA-Z0-9_\$@]){$this->varRx}:?#", array(&$this, 'getNewName'), $tree['code']); if ($this->specialVarRx && preg_match_all("#//''\"\"[0-9]+'#", $tree['code'], $b)) { foreach ($b[0] as $a) { $this->strings[$a] = preg_replace_callback( "#[.,{]?(?<![a-zA-Z0-9_\$@]){$this->specialVarRx}:?#", array(&$this, 'getNewName'), $this->strings[$a] ); } } foreach ($tree['childs'] as $a => &$b) { $this->renameVars($b, false); $tree['code'] = str_replace($a, $b['code'], $tree['code']); unset($tree['childs'][$a]); } } protected function getNewName($m) { $m = $m[0]; $pre = '.' === $m[0] ? '.' : ''; $post = ''; if (',' === $m[0] || '{' === $m[0] || ' ' === $m[0]) { $pre = $m[0]; if (':' === substr($m, -1)) { $post = ':'; $m = (' ' !== $m[0] ? '.' : '') . substr($m, 1, -1); } else $m = substr($m, 1); } else if (':' === substr($m, -1)) { $post = ':'; $m = substr($m, 0, -1); } $post = (isset($this->reserved[$m]) ? ('true' === $m ? '!0' : ('false' === $m ? '!1': $m)) : ( isset($this->local_tree[$m]) ? $this->local_tree[$m] : ( isset($this->used_tree[$m]) ? $this->used_tree[$m] : $m ) ) ) . $post; return '' === $post ? '' : ($pre . ('.' === $post[0] ? substr($post, 1) : $post)); } protected function getNextName(&$tree = array(), &$counter = false) { if (false === $counter) { $counter =& $tree['counter']; isset($counter) || $counter = -1; $exclude = array_flip($tree['used']); } else $exclude = $tree; ++$counter; $len0 = strlen($this->str0); $len1 = strlen($this->str0); $name = $this->str0[$counter % $len0]; $i = intval($counter / $len0) - 1; while ($i>=0) { $name .= $this->str1[ $i % $len1 ]; $i = intval($i / $len1) - 1; } return !(isset($this->reserved[$name]) || isset($exclude[$name])) ? $name : $this->getNextName($exclude, $counter); } protected function restoreCc(&$s, $lf = true) { $lf && $s = str_replace('@#3', '', $s); $s = str_replace('@#1', '@*/', $s); $s = str_replace('2#@', '//@', $s); $s = str_replace('1#@', '/*@', $s); $s = str_replace('##', '#', $s); } }
class Less_Version{ const version = '1.7.0.10'; const less_version = '1.7.0'; const cache_version = '170'; } class Less_Cache{ public static $cache_dir = false; public static $prefix = 'lessphp_'; public static $prefix_vars = 'lessphpvars_'; public static $gc_lifetime = 604800; public static function Get( $less_files, $parser_options = array(), $modify_vars = array() ){ if( isset($parser_options['cache_dir']) ){ Less_Cache::$cache_dir = $parser_options['cache_dir']; } if( empty(Less_Cache::$cache_dir) ){ throw new Exception('cache_dir not set'); } if( isset($parser_options['prefix']) ){ Less_Cache::$prefix = $parser_options['prefix']; } if( empty(Less_Cache::$prefix) ){ throw new Exception('prefix not set'); } if( isset($parser_options['prefix_vars']) ){ Less_Cache::$prefix_vars = $parser_options['prefix_vars']; } if( empty(Less_Cache::$prefix_vars) ){ throw new Exception('prefix_vars not set'); } self::CheckCacheDir(); $less_files = (array)$less_files; if( !empty($modify_vars) ){ $lessvars = Less_Parser::serializeVars($modify_vars); $vars_file = Less_Cache::$cache_dir . Less_Cache::$prefix_vars . sha1($lessvars) . '.less'; if( !file_exists($vars_file) ){ file_put_contents($vars_file, $lessvars); } $less_files += array($vars_file => '/'); } $hash = md5(json_encode($less_files)); $list_file = Less_Cache::$cache_dir . Less_Cache::$prefix . $hash . '.list'; if( !isset($parser_options['use_cache']) || $parser_options['use_cache'] === true ){ if( file_exists($list_file) ){ self::ListFiles($list_file, $list, $cached_name); $compiled_name = self::CompiledName($list, $hash); if( !$cached_name || $cached_name === $compiled_name ){ $output_file = self::OutputFile($compiled_name, $parser_options ); if( $output_file && file_exists($output_file) ){ @touch($list_file); return basename($output_file); } } } } $compiled = self::Cache( $less_files, $parser_options ); if( !$compiled ){ return false; } $compiled_name = self::CompiledName( $less_files, $hash ); $output_file = self::OutputFile($compiled_name, $parser_options ); $list = $less_files; $list[] = $compiled_name; $cache = implode("\n",$list); file_put_contents( $list_file, $cache ); file_put_contents( $output_file, $compiled ); self::CleanCache(); return basename($output_file); } public static function Regen( $less_files, $parser_options = array(), $modify_vars = array() ){ $parser_options['use_cache'] = false; return self::Get( $less_files, $parser_options, $modify_vars ); } public static function Cache( &$less_files, $parser_options = array() ){ $parser_options['cache_dir'] = Less_Cache::$cache_dir; $parser = new Less_Parser($parser_options); foreach($less_files as $file_path => $uri_or_less ){ if( strpos($uri_or_less,"\n") !== false ){ $parser->Parse( $uri_or_less ); continue; } $parser->ParseFile( $file_path, $uri_or_less ); } $compiled = $parser->getCss(); $less_files = $parser->allParsedFiles(); return $compiled; } private static function OutputFile( $compiled_name, $parser_options ){ if( !empty($parser_options['output']) ){ if( preg_match('#[\\\\/]#',$parser_options['output']) ){ return $parser_options['output']; } return Less_Cache::$cache_dir.$parser_options['output']; } return Less_Cache::$cache_dir.$compiled_name; } private static function CompiledName( $files, $extrahash ){ $temp = array(Less_Version::cache_version); foreach($files as $file){ $temp[] = filemtime($file)."\t".filesize($file)."\t".$file; } return Less_Cache::$prefix.sha1(json_encode($temp).$extrahash).'.css'; } public static function SetCacheDir( $dir ){ Less_Cache::$cache_dir = $dir; } public static function CheckCacheDir(){ Less_Cache::$cache_dir = str_replace('\\','/',Less_Cache::$cache_dir); Less_Cache::$cache_dir = rtrim(Less_Cache::$cache_dir,'/').'/'; if( !file_exists(Less_Cache::$cache_dir) ){ if( !mkdir(Less_Cache::$cache_dir) ){ throw new Less_Exception_Parser('Less.php cache directory couldn\'t be created: '.Less_Cache::$cache_dir); } }elseif( !is_dir(Less_Cache::$cache_dir) ){ throw new Less_Exception_Parser('Less.php cache directory doesn\'t exist: '.Less_Cache::$cache_dir); }elseif( !is_writable(Less_Cache::$cache_dir) ){ throw new Less_Exception_Parser('Less.php cache directory isn\'t writable: '.Less_Cache::$cache_dir); } } public static function CleanCache(){ static $clean = false; if( $clean ){ return; } $files = scandir(Less_Cache::$cache_dir); if( $files ){ $check_time = time() - self::$gc_lifetime; foreach($files as $file){ if( strpos($file,Less_Cache::$prefix) !== 0 ){ continue; } $full_path = Less_Cache::$cache_dir . $file; if( !file_exists($full_path) ){ continue; } $mtime = filemtime($full_path); if( $mtime > $check_time ){ continue; } $parts = explode('.',$file); $type = array_pop($parts); if( $type === 'css' ){ continue; } if( $type === 'list' ){ self::ListFiles($full_path, $list, $css_file_name); if( $css_file_name ){ $css_file = Less_Cache::$cache_dir . $css_file_name; if( file_exists($css_file) ){ unlink($css_file); } } } unlink($full_path); } } $clean = true; } static function ListFiles($list_file, &$list, &$css_file_name ){ $list = explode("\n",file_get_contents($list_file)); $css_file_name = array_pop($list); if( !preg_match('/^' . Less_Cache::$prefix . '[a-f0-9]+\.css$/',$css_file_name) ){ $list[] = $css_file_name; $css_file_name = false; } } } class Less_Parser{ public static $default_options = array( 'compress' => false, 'strictUnits' => false, 'strictMath' => false, 'relativeUrls' => true, 'urlArgs' => '', 'numPrecision' => 8, 'import_dirs' => array(), 'import_callback' => null, 'cache_dir' => null, 'cache_method' => 'php', 'cache_callback_get' => null, 'cache_callback_set' => null, 'sourceMap' => false, 'sourceMapBasepath' => null, 'sourceMapWriteTo' => null, 'sourceMapURL' => null, 'indentation' => '  ', 'plugins' => array(), ); public static $options = array(); private $input; private $input_len; private $pos; private $saveStack = array(); private $furthest; private $mb_internal_encoding = ''; private $env; protected $rules = array(); private static $imports = array(); public static $has_extends = false; public static $next_id = 0; public static $contentsMap = array(); public function __construct( $env = null ){ if( $env instanceof Less_Environment ){ $this->env = $env; }else{ $this->SetOptions(Less_Parser::$default_options); $this->Reset( $env ); } if (ini_get('mbstring.func_overload')) { $this->mb_internal_encoding = ini_get('mbstring.internal_encoding'); @ini_set('mbstring.internal_encoding', 'ascii'); } } public function Reset( $options = null ){ $this->rules = array(); self::$imports = array(); self::$has_extends = false; self::$imports = array(); self::$contentsMap = array(); $this->env = new Less_Environment($options); $this->env->Init(); if( is_array($options) ){ $this->SetOptions(Less_Parser::$default_options); $this->SetOptions($options); } } public function SetOptions( $options ){ foreach($options as $option => $value){ $this->SetOption($option,$value); } } public function SetOption($option,$value){ switch($option){ case 'import_dirs': $this->SetImportDirs($value); return; case 'cache_dir': if( is_string($value) ){ Less_Cache::SetCacheDir($value); Less_Cache::CheckCacheDir(); } return; } Less_Parser::$options[$option] = $value; } public function registerFunction($name, $callback) { $this->env->functions[$name] = $callback; } public function unregisterFunction($name) { if( isset($this->env->functions[$name]) ) unset($this->env->functions[$name]); } public function getCss(){ $precision = ini_get('precision'); @ini_set('precision',16); $locale = setlocale(LC_NUMERIC, 0); setlocale(LC_NUMERIC, "C"); try { $root = new Less_Tree_Ruleset(array(), $this->rules ); $root->root = true; $root->firstRoot = true; $this->PreVisitors($root); self::$has_extends = false; $evaldRoot = $root->compile($this->env); $this->PostVisitors($evaldRoot); if( Less_Parser::$options['sourceMap'] ){ $generator = new Less_SourceMap_Generator($evaldRoot, Less_Parser::$contentsMap, Less_Parser::$options ); $css = $generator->generateCSS(); }else{ $css = $evaldRoot->toCSS(); } if( Less_Parser::$options['compress'] ){ $css = preg_replace('/(^(\s)+)|((\s)+$)/', '', $css); } } catch (Exception $exc) { } @ini_set('precision',$precision); setlocale(LC_NUMERIC, $locale); if ($this->mb_internal_encoding != '') { @ini_set("mbstring.internal_encoding", $this->mb_internal_encoding); $this->mb_internal_encoding = ''; } if (!empty($exc)) { throw $exc; } return $css; } private function PreVisitors($root){ if( Less_Parser::$options['plugins'] ){ foreach(Less_Parser::$options['plugins'] as $plugin){ if( !empty($plugin->isPreEvalVisitor) ){ $plugin->run($root); } } } } private function PostVisitors($evaldRoot){ $visitors = array(); $visitors[] = new Less_Visitor_joinSelector(); if( self::$has_extends ){ $visitors[] = new Less_Visitor_processExtends(); } $visitors[] = new Less_Visitor_toCSS(); if( Less_Parser::$options['plugins'] ){ foreach(Less_Parser::$options['plugins'] as $plugin){ if( property_exists($plugin,'isPreEvalVisitor') && $plugin->isPreEvalVisitor ){ continue; } if( property_exists($plugin,'isPreVisitor') && $plugin->isPreVisitor ){ array_unshift( $visitors, $plugin); }else{ $visitors[] = $plugin; } } } for($i = 0; $i < count($visitors); $i++ ){ $visitors[$i]->run($evaldRoot); } } public function parse( $str, $file_uri = null ){ if( !$file_uri ){ $uri_root = ''; $filename = 'anonymous-file-'.Less_Parser::$next_id++.'.less'; }else{ $file_uri = self::WinPath($file_uri); $filename = $file_uri; $uri_root = dirname($file_uri); } $previousFileInfo = $this->env->currentFileInfo; $uri_root = self::WinPath($uri_root); $this->SetFileInfo($filename, $uri_root); $this->input = $str; $this->_parse(); if( $previousFileInfo ){ $this->env->currentFileInfo = $previousFileInfo; } return $this; } public function parseFile( $filename, $uri_root = '', $returnRoot = false){ if( !file_exists($filename) ){ $this->Error(sprintf('File `%s` not found.', $filename)); } if( !$returnRoot && !empty($uri_root) && basename($uri_root) == basename($filename) ){ $uri_root = dirname($uri_root); } $previousFileInfo = $this->env->currentFileInfo; if( $filename ){ $filename = self::WinPath(realpath($filename)); } $uri_root = self::WinPath($uri_root); $this->SetFileInfo($filename, $uri_root); self::AddParsedFile($filename); if( $returnRoot ){ $rules = $this->GetRules( $filename ); $return = new Less_Tree_Ruleset(array(), $rules ); }else{ $this->_parse( $filename ); $return = $this; } if( $previousFileInfo ){ $this->env->currentFileInfo = $previousFileInfo; } return $return; } public function ModifyVars( $vars ){ $this->input = Less_Parser::serializeVars( $vars ); $this->_parse(); return $this; } public function SetFileInfo( $filename, $uri_root = ''){ $filename = Less_Environment::normalizePath($filename); $dirname = preg_replace('/[^\/\\\\]*$/','',$filename); if( !empty($uri_root) ){ $uri_root = rtrim($uri_root,'/').'/'; } $currentFileInfo = array(); if( isset($this->env->currentFileInfo) ){ $currentFileInfo['entryPath'] = $this->env->currentFileInfo['entryPath']; $currentFileInfo['entryUri'] = $this->env->currentFileInfo['entryUri']; $currentFileInfo['rootpath'] = $this->env->currentFileInfo['rootpath']; }else{ $currentFileInfo['entryPath'] = $dirname; $currentFileInfo['entryUri'] = $uri_root; $currentFileInfo['rootpath'] = $dirname; } $currentFileInfo['currentDirectory'] = $dirname; $currentFileInfo['currentUri'] = $uri_root.basename($filename); $currentFileInfo['filename'] = $filename; $currentFileInfo['uri_root'] = $uri_root; if( isset($this->env->currentFileInfo['reference']) && $this->env->currentFileInfo['reference'] ){ $currentFileInfo['reference'] = true; } $this->env->currentFileInfo = $currentFileInfo; } public function SetCacheDir( $dir ){ if( !file_exists($dir) ){ if( mkdir($dir) ){ return true; } throw new Less_Exception_Parser('Less.php cache directory couldn\'t be created: '.$dir); }elseif( !is_dir($dir) ){ throw new Less_Exception_Parser('Less.php cache directory doesn\'t exist: '.$dir); }elseif( !is_writable($dir) ){ throw new Less_Exception_Parser('Less.php cache directory isn\'t writable: '.$dir); }else{ $dir = self::WinPath($dir); Less_Cache::$cache_dir = rtrim($dir,'/').'/'; return true; } } public function SetImportDirs( $dirs ){ Less_Parser::$options['import_dirs'] = array(); foreach($dirs as $path => $uri_root){ $path = self::WinPath($path); if( !empty($path) ){ $path = rtrim($path,'/').'/'; } if ( !is_callable($uri_root) ){ $uri_root = self::WinPath($uri_root); if( !empty($uri_root) ){ $uri_root = rtrim($uri_root,'/').'/'; } } Less_Parser::$options['import_dirs'][$path] = $uri_root; } } private function _parse( $file_path = null ){ $this->rules = array_merge($this->rules, $this->GetRules( $file_path )); } private function GetRules( $file_path ){ $this->SetInput($file_path); $cache_file = $this->CacheFile( $file_path ); if( $cache_file ){ if( Less_Parser::$options['cache_method'] == 'callback' ){ if( is_callable(Less_Parser::$options['cache_callback_get']) ){ $cache = call_user_func_array( Less_Parser::$options['cache_callback_get'], array($this, $file_path, $cache_file) ); if( $cache ){ $this->UnsetInput(); return $cache; } } }elseif( file_exists($cache_file) ){ switch(Less_Parser::$options['cache_method']){ case 'serialize': $cache = unserialize(file_get_contents($cache_file)); if( $cache ){ touch($cache_file); $this->UnsetInput(); return $cache; } break; case 'var_export': case 'php': $this->UnsetInput(); return include($cache_file); } } } $rules = $this->parsePrimary(); if( $this->pos < $this->input_len ){ throw new Less_Exception_Chunk($this->input, null, $this->furthest, $this->env->currentFileInfo); } $this->UnsetInput(); if( $cache_file ){ if( Less_Parser::$options['cache_method'] == 'callback' ){ if( is_callable(Less_Parser::$options['cache_callback_set']) ){ call_user_func_array( Less_Parser::$options['cache_callback_set'], array($this, $file_path, $cache_file, $rules) ); } }else{ switch(Less_Parser::$options['cache_method']){ case 'serialize': file_put_contents( $cache_file, serialize($rules) ); break; case 'php': file_put_contents( $cache_file, '<?php return '.self::ArgString($rules).'; ?>' ); break; case 'var_export': file_put_contents( $cache_file, '<?php return '.var_export($rules,true).'; ?>' ); break; } Less_Cache::CleanCache(); } } return $rules; } public function SetInput( $file_path ){ if( $file_path ){ $this->input = file_get_contents( $file_path ); } $this->pos = $this->furthest = 0; $this->input = preg_replace('/\\G\xEF\xBB\xBF/', '', $this->input); $this->input_len = strlen($this->input); if( Less_Parser::$options['sourceMap'] && $this->env->currentFileInfo ){ $uri = $this->env->currentFileInfo['currentUri']; Less_Parser::$contentsMap[$uri] = $this->input; } } public function UnsetInput(){ unset($this->input, $this->pos, $this->input_len, $this->furthest); $this->saveStack = array(); } public function CacheFile( $file_path ){ if( $file_path && $this->CacheEnabled() ){ $env = get_object_vars($this->env); unset($env['frames']); $parts = array(); $parts[] = $file_path; $parts[] = filesize( $file_path ); $parts[] = filemtime( $file_path ); $parts[] = $env; $parts[] = Less_Version::cache_version; $parts[] = Less_Parser::$options['cache_method']; return Less_Cache::$cache_dir . Less_Cache::$prefix . base_convert( sha1(json_encode($parts) ), 16, 36) . '.lesscache'; } } static function AddParsedFile($file){ self::$imports[] = $file; } static function AllParsedFiles(){ return self::$imports; } static function FileParsed($file){ return in_array($file,self::$imports); } function save() { $this->saveStack[] = $this->pos; } private function restore() { $this->pos = array_pop($this->saveStack); } private function forget(){ array_pop($this->saveStack); } private function isWhitespace($offset = 0) { return preg_match('/\s/',$this->input[ $this->pos + $offset]); } private function match($toks){ foreach($toks as $tok){ $char = $tok[0]; if( $char === '/' ){ $match = $this->MatchReg($tok); if( $match ){ return count($match) === 1 ? $match[0] : $match; } }elseif( $char === '#' ){ $match = $this->MatchChar($tok[1]); }else{ $match = $this->$tok(); } if( $match ){ return $match; } } } private function MatchFuncs($toks){ if( $this->pos < $this->input_len ){ foreach($toks as $tok){ $match = $this->$tok(); if( $match ){ return $match; } } } } private function MatchChar($tok){ if( ($this->pos < $this->input_len) && ($this->input[$this->pos] === $tok) ){ $this->skipWhitespace(1); return $tok; } } private function MatchReg($tok){ if( preg_match($tok, $this->input, $match, 0, $this->pos) ){ $this->skipWhitespace(strlen($match[0])); return $match; } } public function PeekReg($tok){ return preg_match($tok, $this->input, $match, 0, $this->pos); } public function PeekChar($tok){ return ($this->pos < $this->input_len) && ($this->input[$this->pos] === $tok ); } public function skipWhitespace($length){ $this->pos += $length; for(; $this->pos < $this->input_len; $this->pos++ ){ $c = $this->input[$this->pos]; if( ($c !== "\n") && ($c !== "\r") && ($c !== "\t") && ($c !== ' ') ){ break; } } } public function expect($tok, $msg = NULL) { $result = $this->match( array($tok) ); if (!$result) { $this->Error( $msg ? "Expected '" . $tok . "' got '" . $this->input[$this->pos] . "'" : $msg ); } else { return $result; } } public function expectChar($tok, $msg = null ){ $result = $this->MatchChar($tok); if( !$result ){ $this->Error( $msg ? "Expected '" . $tok . "' got '" . $this->input[$this->pos] . "'" : $msg ); }else{ return $result; } } private function parsePrimary(){ $root = array(); while( true ){ if( $this->pos >= $this->input_len ){ break; } $node = $this->parseExtend(true); if( $node ){ $root = array_merge($root,$node); continue; } $node = $this->MatchFuncs( array( 'parseMixinDefinition', 'parseNameValue', 'parseRule', 'parseRuleset', 'parseMixinCall', 'parseComment', 'parseRulesetCall', 'parseDirective')); if( $node ){ $root[] = $node; }elseif( !$this->MatchReg('/\\G[\s\n;]+/') ){ break; } if( $this->PeekChar('}') ){ break; } } return $root; } private function parseComment(){ if( $this->input[$this->pos] !== '/' ){ return; } if( $this->input[$this->pos+1] === '/' ){ $match = $this->MatchReg('/\\G\/\/.*/'); return $this->NewObj4('Less_Tree_Comment',array($match[0], true, $this->pos, $this->env->currentFileInfo)); } $comment = $this->MatchReg('/\\G\/\*(?s).*?\*+\/\n?/'); if( $comment ){ return $this->NewObj4('Less_Tree_Comment',array($comment[0], false, $this->pos, $this->env->currentFileInfo)); } } private function parseComments(){ $comments = array(); while( $this->pos < $this->input_len ){ $comment = $this->parseComment(); if( !$comment ){ break; } $comments[] = $comment; } return $comments; } private function parseEntitiesQuoted() { $j = $this->pos; $e = false; $index = $this->pos; if( $this->input[$this->pos] === '~' ){ $j++; $e = true; } if( $this->input[$j] != '"' && $this->input[$j] !== "'" ){ return; } if ($e) { $this->MatchChar('~'); } $str = $this->MatchReg('/\\G"((?:[^"\\\\\r\n]|\\\\.|\\\\\r\n|\\\\[\n\r\f])*)"|\'((?:[^\'\\\\\r\n]|\\\\.|\\\\\r\n|\\\\[\n\r\f])*)\'/'); if( $str ){ $result = $str[0][0] == '"' ? $str[1] : $str[2]; return $this->NewObj5('Less_Tree_Quoted',array($str[0], $result, $e, $index, $this->env->currentFileInfo) ); } return; } private function parseEntitiesKeyword(){ $k = $this->MatchReg('/\\G%|\\G[_A-Za-z-][_A-Za-z0-9-]*/'); if( $k ){ $k = $k[0]; $color = $this->fromKeyword($k); if( $color ){ return $color; } return $this->NewObj1('Less_Tree_Keyword',$k); } } private function FromKeyword( $keyword ){ $keyword = strtolower($keyword); if( Less_Colors::hasOwnProperty($keyword) ){ return $this->NewObj1('Less_Tree_Color',substr(Less_Colors::color($keyword), 1)); } if( $keyword === 'transparent' ){ return $this->NewObj3('Less_Tree_Color', array( array(0, 0, 0), 0, true)); } } private function parseEntitiesCall(){ $index = $this->pos; if( !preg_match('/\\G([\w-]+|%|progid:[\w\.]+)\(/', $this->input, $name,0,$this->pos) ){ return; } $name = $name[1]; $nameLC = strtolower($name); if ($nameLC === 'url') { return null; } $this->pos += strlen($name); if( $nameLC === 'alpha' ){ $alpha_ret = $this->parseAlpha(); if( $alpha_ret ){ return $alpha_ret; } } $this->MatchChar('('); $args = $this->parseEntitiesArguments(); if( !$this->MatchChar(')') ){ return; } if ($name) { return $this->NewObj4('Less_Tree_Call',array($name, $args, $index, $this->env->currentFileInfo) ); } } private function parseEntitiesArguments(){ $args = array(); while( true ){ $arg = $this->MatchFuncs( array('parseEntitiesAssignment','parseExpression') ); if( !$arg ){ break; } $args[] = $arg; if( !$this->MatchChar(',') ){ break; } } return $args; } private function parseEntitiesLiteral(){ return $this->MatchFuncs( array('parseEntitiesDimension','parseEntitiesColor','parseEntitiesQuoted','parseUnicodeDescriptor') ); } private function parseEntitiesAssignment() { $key = $this->MatchReg('/\\G\w+(?=\s?=)/'); if( !$key ){ return; } if( !$this->MatchChar('=') ){ return; } $value = $this->parseEntity(); if( $value ){ return $this->NewObj2('Less_Tree_Assignment',array($key[0], $value)); } } private function parseEntitiesUrl(){ if( $this->input[$this->pos] !== 'u' || !$this->matchReg('/\\Gurl\(/') ){ return; } $value = $this->match( array('parseEntitiesQuoted','parseEntitiesVariable','/\\Gdata\:.*?[^\)]+/','/\\G(?:(?:\\\\[\(\)\'"])|[^\(\)\'"])+/') ); if( !$value ){ $value = ''; } $this->expectChar(')'); if( isset($value->value) || $value instanceof Less_Tree_Variable ){ return $this->NewObj2('Less_Tree_Url',array($value, $this->env->currentFileInfo)); } return $this->NewObj2('Less_Tree_Url', array( $this->NewObj1('Less_Tree_Anonymous',$value), $this->env->currentFileInfo) ); } private function parseEntitiesVariable(){ $index = $this->pos; if ($this->PeekChar('@') && ($name = $this->MatchReg('/\\G@@?[\w-]+/'))) { return $this->NewObj3('Less_Tree_Variable', array( $name[0], $index, $this->env->currentFileInfo)); } } private function parseEntitiesVariableCurly() { $index = $this->pos; if( $this->input_len > ($this->pos+1) && $this->input[$this->pos] === '@' && ($curly = $this->MatchReg('/\\G@\{([\w-]+)\}/')) ){ return $this->NewObj3('Less_Tree_Variable',array('@'.$curly[1], $index, $this->env->currentFileInfo)); } } private function parseEntitiesColor(){ if ($this->PeekChar('#') && ($rgb = $this->MatchReg('/\\G#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})/'))) { return $this->NewObj1('Less_Tree_Color',$rgb[1]); } } private function parseEntitiesDimension(){ $c = @ord($this->input[$this->pos]); if (($c > 57 || $c < 43) || $c === 47 || $c == 44){ return; } $value = $this->MatchReg('/\\G([+-]?\d*\.?\d+)(%|[a-z]+)?/'); if( $value ){ if( isset($value[2]) ){ return $this->NewObj2('Less_Tree_Dimension', array($value[1],$value[2])); } return $this->NewObj1('Less_Tree_Dimension',$value[1]); } } function parseUnicodeDescriptor() { $ud = $this->MatchReg('/\\G(U\+[0-9a-fA-F?]+)(\-[0-9a-fA-F?]+)?/'); if( $ud ){ return $this->NewObj1('Less_Tree_UnicodeDescriptor', $ud[0]); } } private function parseEntitiesJavascript(){ $e = false; $j = $this->pos; if( $this->input[$j] === '~' ){ $j++; $e = true; } if( $this->input[$j] !== '`' ){ return; } if( $e ){ $this->MatchChar('~'); } $str = $this->MatchReg('/\\G`([^`]*)`/'); if( $str ){ return $this->NewObj3('Less_Tree_Javascript', array($str[1], $this->pos, $e)); } } private function parseVariable(){ if ($this->PeekChar('@') && ($name = $this->MatchReg('/\\G(@[\w-]+)\s*:/'))) { return $name[1]; } } private function parseRulesetCall(){ if( $this->input[$this->pos] === '@' && ($name = $this->MatchReg('/\\G(@[\w-]+)\s*\(\s*\)\s*;/')) ){ return $this->NewObj1('Less_Tree_RulesetCall', $name[1] ); } } function parseExtend($isRule = false){ $index = $this->pos; $extendList = array(); if( !$this->MatchReg( $isRule ? '/\\G&:extend\(/' : '/\\G:extend\(/' ) ){ return; } do{ $option = null; $elements = array(); while( true ){ $option = $this->MatchReg('/\\G(all)(?=\s*(\)|,))/'); if( $option ){ break; } $e = $this->parseElement(); if( !$e ){ break; } $elements[] = $e; } if( $option ){ $option = $option[1]; } $extendList[] = $this->NewObj3('Less_Tree_Extend', array( $this->NewObj1('Less_Tree_Selector',$elements), $option, $index )); }while( $this->MatchChar(",") ); $this->expect('/\\G\)/'); if( $isRule ){ $this->expect('/\\G;/'); } return $extendList; } private function parseMixinCall(){ $char = $this->input[$this->pos]; if( $char !== '.' && $char !== '#' ){ return; } $index = $this->pos; $this->save(); $elements = $this->parseMixinCallElements(); if( $elements ){ if( $this->MatchChar('(') ){ $returned = $this->parseMixinArgs(true); $args = $returned['args']; $this->expectChar(')'); }else{ $args = array(); } $important = $this->parseImportant(); if( $this->parseEnd() ){ $this->forget(); return $this->NewObj5('Less_Tree_Mixin_Call', array( $elements, $args, $index, $this->env->currentFileInfo, $important)); } } $this->restore(); } private function parseMixinCallElements(){ $elements = array(); $c = null; while( true ){ $elemIndex = $this->pos; $e = $this->MatchReg('/\\G[#.](?:[\w-]|\\\\(?:[A-Fa-f0-9]{1,6} ?|[^A-Fa-f0-9]))+/'); if( !$e ){ break; } $elements[] = $this->NewObj4('Less_Tree_Element', array($c, $e[0], $elemIndex, $this->env->currentFileInfo)); $c = $this->MatchChar('>'); } return $elements; } private function parseMixinArgs( $isCall ){ $expressions = array(); $argsSemiColon = array(); $isSemiColonSeperated = null; $argsComma = array(); $expressionContainsNamed = null; $name = null; $returner = array('args'=>array(), 'variadic'=> false); $this->save(); while( true ){ if( $isCall ){ $arg = $this->MatchFuncs( array( 'parseDetachedRuleset','parseExpression' ) ); } else { $this->parseComments(); if( $this->input[ $this->pos ] === '.' && $this->MatchReg('/\\G\.{3}/') ){ $returner['variadic'] = true; if( $this->MatchChar(";") && !$isSemiColonSeperated ){ $isSemiColonSeperated = true; } if( $isSemiColonSeperated ){ $argsSemiColon[] = array('variadic'=>true); }else{ $argsComma[] = array('variadic'=>true); } break; } $arg = $this->MatchFuncs( array('parseEntitiesVariable','parseEntitiesLiteral','parseEntitiesKeyword') ); } if( !$arg ){ break; } $nameLoop = null; if( $arg instanceof Less_Tree_Expression ){ $arg->throwAwayComments(); } $value = $arg; $val = null; if( $isCall ){ if( property_exists($arg,'value') && count($arg->value) == 1 ){ $val = $arg->value[0]; } } else { $val = $arg; } if( $val instanceof Less_Tree_Variable ){ if( $this->MatchChar(':') ){ if( $expressions ){ if( $isSemiColonSeperated ){ $this->Error('Cannot mix ; and , as delimiter types'); } $expressionContainsNamed = true; } $value = null; if( $isCall ){ $value = $this->parseDetachedRuleset(); } if( !$value ){ $value = $this->parseExpression(); } if( !$value ){ if( $isCall ){ $this->Error('could not understand value for named argument'); } else { $this->restore(); $returner['args'] = array(); return $returner; } } $nameLoop = ($name = $val->name); }elseif( !$isCall && $this->MatchReg('/\\G\.{3}/') ){ $returner['variadic'] = true; if( $this->MatchChar(";") && !$isSemiColonSeperated ){ $isSemiColonSeperated = true; } if( $isSemiColonSeperated ){ $argsSemiColon[] = array('name'=> $arg->name, 'variadic' => true); }else{ $argsComma[] = array('name'=> $arg->name, 'variadic' => true); } break; }elseif( !$isCall ){ $name = $nameLoop = $val->name; $value = null; } } if( $value ){ $expressions[] = $value; } $argsComma[] = array('name'=>$nameLoop, 'value'=>$value ); if( $this->MatchChar(',') ){ continue; } if( $this->MatchChar(';') || $isSemiColonSeperated ){ if( $expressionContainsNamed ){ $this->Error('Cannot mix ; and , as delimiter types'); } $isSemiColonSeperated = true; if( count($expressions) > 1 ){ $value = $this->NewObj1('Less_Tree_Value', $expressions); } $argsSemiColon[] = array('name'=>$name, 'value'=>$value ); $name = null; $expressions = array(); $expressionContainsNamed = false; } } $this->forget(); $returner['args'] = ($isSemiColonSeperated ? $argsSemiColon : $argsComma); return $returner; } private function parseMixinDefinition(){ $cond = null; $char = $this->input[$this->pos]; if( ($char !== '.' && $char !== '#') || ($char === '{' && $this->PeekReg('/\\G[^{]*\}/')) ){ return; } $this->save(); $match = $this->MatchReg('/\\G([#.](?:[\w-]|\\\(?:[A-Fa-f0-9]{1,6} ?|[^A-Fa-f0-9]))+)\s*\(/'); if( $match ){ $name = $match[1]; $argInfo = $this->parseMixinArgs( false ); $params = $argInfo['args']; $variadic = $argInfo['variadic']; if( !$this->MatchChar(')') ){ $this->furthest = $this->pos; $this->restore(); return; } $this->parseComments(); if ($this->MatchReg('/\\Gwhen/')) { $cond = $this->expect('parseConditions', 'Expected conditions'); } $ruleset = $this->parseBlock(); if( is_array($ruleset) ){ $this->forget(); return $this->NewObj5('Less_Tree_Mixin_Definition', array( $name, $params, $ruleset, $cond, $variadic)); } $this->restore(); }else{ $this->forget(); } } private function parseEntity(){ return $this->MatchFuncs( array('parseEntitiesLiteral','parseEntitiesVariable','parseEntitiesUrl','parseEntitiesCall','parseEntitiesKeyword','parseEntitiesJavascript','parseComment') ); } private function parseEnd(){ return $this->MatchChar(';') || $this->PeekChar('}'); } private function parseAlpha(){ if ( ! $this->MatchReg('/\\G\(opacity=/i')) { return; } $value = $this->MatchReg('/\\G[0-9]+/'); if( $value ){ $value = $value[0]; }else{ $value = $this->parseEntitiesVariable(); if( !$value ){ return; } } $this->expectChar(')'); return $this->NewObj1('Less_Tree_Alpha',$value); } private function parseElement(){ $c = $this->parseCombinator(); $index = $this->pos; $e = $this->match( array('/\\G(?:\d+\.\d+|\d+)%/', '/\\G(?:[.#]?|:*)(?:[\w-]|[^\x00-\x9f]|\\\\(?:[A-Fa-f0-9]{1,6} ?|[^A-Fa-f0-9]))+/', '#*', '#&', 'parseAttribute', '/\\G\([^()@]+\)/', '/\\G[\.#](?=@)/', 'parseEntitiesVariableCurly') ); if( is_null($e) ){ $this->save(); if( $this->MatchChar('(') ){ if( ($v = $this->parseSelector()) && $this->MatchChar(')') ){ $e = $this->NewObj1('Less_Tree_Paren',$v); $this->forget(); }else{ $this->restore(); } }else{ $this->forget(); } } if( !is_null($e) ){ return $this->NewObj4('Less_Tree_Element',array( $c, $e, $index, $this->env->currentFileInfo)); } } private function parseCombinator(){ if( $this->pos < $this->input_len ){ $c = $this->input[$this->pos]; if ($c === '>' || $c === '+' || $c === '~' || $c === '|' || $c === '^' ){ $this->pos++; if( $this->input[$this->pos] === '^' ){ $c = '^^'; $this->pos++; } $this->skipWhitespace(0); return $c; } if( $this->pos > 0 && $this->isWhitespace(-1) ){ return ' '; } } } private function parseLessSelector(){ return $this->parseSelector(true); } private function parseSelector( $isLess = false ){ $elements = array(); $extendList = array(); $condition = null; $when = false; $extend = false; $e = null; $c = null; $index = $this->pos; while( ($isLess && ($extend = $this->parseExtend())) || ($isLess && ($when = $this->MatchReg('/\\Gwhen/') )) || ($e = $this->parseElement()) ){ if( $when ){ $condition = $this->expect('parseConditions', 'expected condition'); }elseif( $condition ){ }elseif( $extend ){ $extendList = array_merge($extendList,$extend); }else{ if( $this->pos < $this->input_len ){ $c = $this->input[ $this->pos ]; } $elements[] = $e; $e = null; } if( $c === '{' || $c === '}' || $c === ';' || $c === ',' || $c === ')') { break; } } if( $elements ){ return $this->NewObj5('Less_Tree_Selector',array($elements, $extendList, $condition, $index, $this->env->currentFileInfo)); } if( $extendList ) { $this->Error('Extend must be used to extend a selector, it cannot be used on its own'); } } private function parseTag(){ return ( $tag = $this->MatchReg('/\\G[A-Za-z][A-Za-z-]*[0-9]?/') ) ? $tag : $this->MatchChar('*'); } private function parseAttribute(){ $val = null; if( !$this->MatchChar('[') ){ return; } $key = $this->parseEntitiesVariableCurly(); if( !$key ){ $key = $this->expect('/\\G(?:[_A-Za-z0-9-\*]*\|)?(?:[_A-Za-z0-9-]|\\\\.)+/'); } $op = $this->MatchReg('/\\G[|~*$^]?=/'); if( $op ){ $val = $this->match( array('parseEntitiesQuoted','/\\G[0-9]+%/','/\\G[\w-]+/','parseEntitiesVariableCurly') ); } $this->expectChar(']'); return $this->NewObj3('Less_Tree_Attribute',array( $key, $op[0], $val)); } private function parseBlock(){ if( $this->MatchChar('{') ){ $content = $this->parsePrimary(); if( $this->MatchChar('}') ){ return $content; } } } private function parseBlockRuleset(){ $block = $this->parseBlock(); if( $block ){ $block = $this->NewObj2('Less_Tree_Ruleset',array( null, $block)); } return $block; } private function parseDetachedRuleset(){ $blockRuleset = $this->parseBlockRuleset(); if( $blockRuleset ){ return $this->NewObj1('Less_Tree_DetachedRuleset',$blockRuleset); } } private function parseRuleset(){ $selectors = array(); $this->save(); while( true ){ $s = $this->parseLessSelector(); if( !$s ){ break; } $selectors[] = $s; $this->parseComments(); if( $s->condition && count($selectors) > 1 ){ $this->Error('Guards are only currently allowed on a single selector.'); } if( !$this->MatchChar(',') ){ break; } if( $s->condition ){ $this->Error('Guards are only currently allowed on a single selector.'); } $this->parseComments(); } if( $selectors ){ $rules = $this->parseBlock(); if( is_array($rules) ){ $this->forget(); return $this->NewObj2('Less_Tree_Ruleset',array( $selectors, $rules)); } } $this->furthest = $this->pos; $this->restore(); } private function parseNameValue(){ $index = $this->pos; $this->save(); $match = $this->MatchReg('/\\G([a-zA-Z\-]+)\s*:\s*([\'"]?[#a-zA-Z0-9\-%\.,]+?[\'"]?) *(! *important)?\s*([;}])/'); if( $match ){ if( $match[4] == '}' ){ $this->pos = $index + strlen($match[0])-1; } if( $match[3] ){ $match[2] .= ' !important'; } return $this->NewObj4('Less_Tree_NameValue',array( $match[1], $match[2], $index, $this->env->currentFileInfo)); } $this->restore(); } private function parseRule( $tryAnonymous = null ){ $merge = false; $startOfRule = $this->pos; $c = $this->input[$this->pos]; if( $c === '.' || $c === '#' || $c === '&' ){ return; } $this->save(); $name = $this->MatchFuncs( array('parseVariable','parseRuleProperty')); if( $name ){ $isVariable = is_string($name); $value = null; if( $isVariable ){ $value = $this->parseDetachedRuleset(); } $important = null; if( !$value ){ if( !$tryAnonymous && (Less_Parser::$options['compress'] || $isVariable) ){ $value = $this->MatchFuncs( array('parseValue','parseAnonymousValue')); }else{ $value = $this->MatchFuncs( array('parseAnonymousValue','parseValue')); } $important = $this->parseImportant(); if( !$isVariable && is_array($name) ){ $nm = array_pop($name); if( $nm->value ){ $merge = $nm->value; } } } if( $value && $this->parseEnd() ){ $this->forget(); return $this->NewObj6('Less_Tree_Rule',array( $name, $value, $important, $merge, $startOfRule, $this->env->currentFileInfo)); }else{ $this->furthest = $this->pos; $this->restore(); if( $value && !$tryAnonymous ){ return $this->parseRule(true); } } }else{ $this->forget(); } } function parseAnonymousValue(){ if( preg_match('/\\G([^@+\/\'"*`(;{}-]*);/',$this->input, $match, 0, $this->pos) ){ $this->pos += strlen($match[1]); return $this->NewObj1('Less_Tree_Anonymous',$match[1]); } } private function parseImport(){ $this->save(); $dir = $this->MatchReg('/\\G@import?\s+/'); if( $dir ){ $options = $this->parseImportOptions(); $path = $this->MatchFuncs( array('parseEntitiesQuoted','parseEntitiesUrl')); if( $path ){ $features = $this->parseMediaFeatures(); if( $this->MatchChar(';') ){ if( $features ){ $features = $this->NewObj1('Less_Tree_Value',$features); } $this->forget(); return $this->NewObj5('Less_Tree_Import',array( $path, $features, $options, $this->pos, $this->env->currentFileInfo)); } } } $this->restore(); } private function parseImportOptions(){ $options = array(); if( !$this->MatchChar('(') ){ return $options; } do{ $optionName = $this->parseImportOption(); if( $optionName ){ $value = true; switch( $optionName ){ case "css": $optionName = "less"; $value = false; break; case "once": $optionName = "multiple"; $value = false; break; } $options[$optionName] = $value; if( !$this->MatchChar(',') ){ break; } } }while( $optionName ); $this->expectChar(')'); return $options; } private function parseImportOption(){ $opt = $this->MatchReg('/\\G(less|css|multiple|once|inline|reference|optional)/'); if( $opt ){ return $opt[1]; } } private function parseMediaFeature() { $nodes = array(); do{ $e = $this->MatchFuncs(array('parseEntitiesKeyword','parseEntitiesVariable')); if( $e ){ $nodes[] = $e; } elseif ($this->MatchChar('(')) { $p = $this->parseProperty(); $e = $this->parseValue(); if ($this->MatchChar(')')) { if ($p && $e) { $r = $this->NewObj7('Less_Tree_Rule', array( $p, $e, null, null, $this->pos, $this->env->currentFileInfo, true)); $nodes[] = $this->NewObj1('Less_Tree_Paren',$r); } elseif ($e) { $nodes[] = $this->NewObj1('Less_Tree_Paren',$e); } else { return null; } } else return null; } } while ($e); if ($nodes) { return $this->NewObj1('Less_Tree_Expression',$nodes); } } private function parseMediaFeatures() { $features = array(); do{ $e = $this->parseMediaFeature(); if( $e ){ $features[] = $e; if (!$this->MatchChar(',')) break; }else{ $e = $this->parseEntitiesVariable(); if( $e ){ $features[] = $e; if (!$this->MatchChar(',')) break; } } } while ($e); return $features ? $features : null; } private function parseMedia() { if( $this->MatchReg('/\\G@media/') ){ $features = $this->parseMediaFeatures(); $rules = $this->parseBlock(); if( is_array($rules) ){ return $this->NewObj4('Less_Tree_Media',array( $rules, $features, $this->pos, $this->env->currentFileInfo)); } } } private function parseDirective(){ if( !$this->PeekChar('@') ){ return; } $rules = null; $index = $this->pos; $hasBlock = true; $hasIdentifier = false; $hasExpression = false; $hasUnknown = false; $value = $this->MatchFuncs(array('parseImport','parseMedia')); if( $value ){ return $value; } $this->save(); $name = $this->MatchReg('/\\G@[a-z-]+/'); if( !$name ) return; $name = $name[0]; $nonVendorSpecificName = $name; $pos = strpos($name,'-', 2); if( $name[1] == '-' && $pos > 0 ){ $nonVendorSpecificName = "@" . substr($name, $pos + 1); } switch( $nonVendorSpecificName ){ case "@charset": $hasIdentifier = true; $hasBlock = false; break; case "@namespace": $hasExpression = true; $hasBlock = false; break; case "@keyframes": $hasIdentifier = true; break; case "@host": case "@page": case "@document": case "@supports": $hasUnknown = true; break; } if( $hasIdentifier ){ $value = $this->parseEntity(); if( !$value ){ $this->error("expected " . $name . " identifier"); } } else if( $hasExpression ){ $value = $this->parseExpression(); if( !$value ){ $this->error("expected " . $name. " expression"); } } else if ($hasUnknown) { $value = $this->MatchReg('/\\G[^{;]+/'); if( $value ){ $value = $this->NewObj1('Less_Tree_Anonymous',trim($value[0])); } } if( $hasBlock ){ $rules = $this->parseBlockRuleset(); } if( $rules || (!$hasBlock && $value && $this->MatchChar(';'))) { $this->forget(); return $this->NewObj5('Less_Tree_Directive',array($name, $value, $rules, $index, $this->env->currentFileInfo)); } $this->restore(); } private function parseValue(){ $expressions = array(); do{ $e = $this->parseExpression(); if( $e ){ $expressions[] = $e; if (! $this->MatchChar(',')) { break; } } }while($e); if( $expressions ){ return $this->NewObj1('Less_Tree_Value',$expressions); } } private function parseImportant (){ if( $this->PeekChar('!') && $this->MatchReg('/\\G! *important/') ){ return ' !important'; } } private function parseSub (){ if( $this->MatchChar('(') ){ $a = $this->parseAddition(); if( $a ){ $this->expectChar(')'); return $this->NewObj2('Less_Tree_Expression',array( array($a), true) ); } } } function parseMultiplication(){ $return = $m = $this->parseOperand(); if( $return ){ while( true ){ $isSpaced = $this->isWhitespace( -1 ); if( $this->PeekReg('/\\G\/[*\/]/') ){ break; } $op = $this->MatchChar('/'); if( !$op ){ $op = $this->MatchChar('*'); if( !$op ){ break; } } $a = $this->parseOperand(); if(!$a) { break; } $m->parensInOp = true; $a->parensInOp = true; $return = $this->NewObj3('Less_Tree_Operation',array( $op, array( $return, $a ), $isSpaced) ); } } return $return; } private function parseAddition (){ $return = $m = $this->parseMultiplication(); if( $return ){ while( true ){ $isSpaced = $this->isWhitespace( -1 ); $op = $this->MatchReg('/\\G[-+]\s+/'); if( $op ){ $op = $op[0]; }else{ if( !$isSpaced ){ $op = $this->match(array('#+','#-')); } if( !$op ){ break; } } $a = $this->parseMultiplication(); if( !$a ){ break; } $m->parensInOp = true; $a->parensInOp = true; $return = $this->NewObj3('Less_Tree_Operation',array($op, array($return, $a), $isSpaced)); } } return $return; } private function parseConditions() { $index = $this->pos; $return = $a = $this->parseCondition(); if( $a ){ while( true ){ if( !$this->PeekReg('/\\G,\s*(not\s*)?\(/') || !$this->MatchChar(',') ){ break; } $b = $this->parseCondition(); if( !$b ){ break; } $return = $this->NewObj4('Less_Tree_Condition',array('or', $return, $b, $index)); } return $return; } } private function parseCondition() { $index = $this->pos; $negate = false; $c = null; if ($this->MatchReg('/\\Gnot/')) $negate = true; $this->expectChar('('); $a = $this->MatchFuncs(array('parseAddition','parseEntitiesKeyword','parseEntitiesQuoted')); if( $a ){ $op = $this->MatchReg('/\\G(?:>=|<=|=<|[<=>])/'); if( $op ){ $b = $this->MatchFuncs(array('parseAddition','parseEntitiesKeyword','parseEntitiesQuoted')); if( $b ){ $c = $this->NewObj5('Less_Tree_Condition',array($op[0], $a, $b, $index, $negate)); } else { $this->Error('Unexpected expression'); } } else { $k = $this->NewObj1('Less_Tree_Keyword','true'); $c = $this->NewObj5('Less_Tree_Condition',array('=', $a, $k, $index, $negate)); } $this->expectChar(')'); return $this->MatchReg('/\\Gand/') ? $this->NewObj3('Less_Tree_Condition',array('and', $c, $this->parseCondition())) : $c; } } private function parseOperand (){ $negate = false; $offset = $this->pos+1; if( $offset >= $this->input_len ){ return; } $char = $this->input[$offset]; if( $char === '@' || $char === '(' ){ $negate = $this->MatchChar('-'); } $o = $this->MatchFuncs(array('parseSub','parseEntitiesDimension','parseEntitiesColor','parseEntitiesVariable','parseEntitiesCall')); if( $negate ){ $o->parensInOp = true; $o = $this->NewObj1('Less_Tree_Negative',$o); } return $o; } private function parseExpression (){ $entities = array(); do{ $e = $this->MatchFuncs(array('parseAddition','parseEntity')); if( $e ){ $entities[] = $e; if( !$this->PeekReg('/\\G\/[\/*]/') ){ $delim = $this->MatchChar('/'); if( $delim ){ $entities[] = $this->NewObj1('Less_Tree_Anonymous',$delim); } } } }while($e); if( $entities ){ return $this->NewObj1('Less_Tree_Expression',$entities); } } private function parseProperty (){ $name = $this->MatchReg('/\\G(\*?-?[_a-zA-Z0-9-]+)\s*:/'); if( $name ){ return $name[1]; } } private function parseRuleProperty(){ $offset = $this->pos; $name = array(); $index = array(); $length = 0; $this->rulePropertyMatch('/\\G(\*?)/', $offset, $length, $index, $name ); while( $this->rulePropertyMatch('/\\G((?:[\w-]+)|(?:@\{[\w-]+\}))/', $offset, $length, $index, $name )); if( (count($name) > 1) && $this->rulePropertyMatch('/\\G\s*((?:\+_|\+)?)\s*:/', $offset, $length, $index, $name) ){ $this->skipWhitespace($length); if( $name[0] === '' ){ array_shift($name); array_shift($index); } foreach($name as $k => $s ){ if( !$s || $s[0] !== '@' ){ $name[$k] = $this->NewObj1('Less_Tree_Keyword',$s); }else{ $name[$k] = $this->NewObj3('Less_Tree_Variable',array('@' . substr($s,2,-1), $index[$k], $this->env->currentFileInfo)); } } return $name; } } private function rulePropertyMatch( $re, &$offset, &$length, &$index, &$name ){ preg_match($re, $this->input, $a, 0, $offset); if( $a ){ $index[] = $this->pos + $length; $length += strlen($a[0]); $offset += strlen($a[0]); $name[] = $a[1]; return true; } } public static function serializeVars( $vars ){ $s = ''; foreach($vars as $name => $value){ $s .= (($name[0] === '@') ? '' : '@') . $name .': '. $value . ((substr($value,-1) === ';') ? '' : ';'); } return $s; } public static function is_method($a,$b){ return is_object($a) && method_exists($a,$b); } public static function round($i, $precision = 0){ $precision = pow(10,$precision); $i = $i*$precision; $ceil = ceil($i); $floor = floor($i); if( ($ceil - $i) <= ($i - $floor) ){ return $ceil/$precision; }else{ return $floor/$precision; } } public function NewObj0($class){ $obj = new $class(); if( $this->CacheEnabled() ){ $obj->cache_string = ' new '.$class.'()'; } return $obj; } public function NewObj1($class, $arg){ $obj = new $class( $arg ); if( $this->CacheEnabled() ){ $obj->cache_string = ' new '.$class.'('.Less_Parser::ArgString($arg).')'; } return $obj; } public function NewObj2($class, $args){ $obj = new $class( $args[0], $args[1] ); if( $this->CacheEnabled() ){ $this->ObjCache( $obj, $class, $args); } return $obj; } public function NewObj3($class, $args){ $obj = new $class( $args[0], $args[1], $args[2] ); if( $this->CacheEnabled() ){ $this->ObjCache( $obj, $class, $args); } return $obj; } public function NewObj4($class, $args){ $obj = new $class( $args[0], $args[1], $args[2], $args[3] ); if( $this->CacheEnabled() ){ $this->ObjCache( $obj, $class, $args); } return $obj; } public function NewObj5($class, $args){ $obj = new $class( $args[0], $args[1], $args[2], $args[3], $args[4] ); if( $this->CacheEnabled() ){ $this->ObjCache( $obj, $class, $args); } return $obj; } public function NewObj6($class, $args){ $obj = new $class( $args[0], $args[1], $args[2], $args[3], $args[4], $args[5] ); if( $this->CacheEnabled() ){ $this->ObjCache( $obj, $class, $args); } return $obj; } public function NewObj7($class, $args){ $obj = new $class( $args[0], $args[1], $args[2], $args[3], $args[4], $args[5], $args[6] ); if( $this->CacheEnabled() ){ $this->ObjCache( $obj, $class, $args); } return $obj; } public function ObjCache($obj, $class, $args=array()){ $obj->cache_string = ' new '.$class.'('. self::ArgCache($args).')'; } public function ArgCache($args){ return implode(',',array_map( array('Less_Parser','ArgString'),$args)); } public static function ArgString($arg){ $type = gettype($arg); if( $type === 'object'){ $string = $arg->cache_string; unset($arg->cache_string); return $string; }elseif( $type === 'array' ){ $string = ' Array('; foreach($arg as $k => $a){ $string .= var_export($k,true).' => '.self::ArgString($a).','; } return $string . ')'; } return var_export($arg,true); } public function Error($msg){ throw new Less_Exception_Parser($msg, null, $this->furthest, $this->env->currentFileInfo); } public static function WinPath($path){ return str_replace('\\', '/', $path); } public function CacheEnabled(){ return (Less_Parser::$options['cache_method'] && (Less_Cache::$cache_dir || (Less_Parser::$options['cache_method'] == 'callback'))); } } class Less_Colors { public static $colors = array( 'aliceblue'=>'#f0f8ff', 'antiquewhite'=>'#faebd7', 'aqua'=>'#00ffff', 'aquamarine'=>'#7fffd4', 'azure'=>'#f0ffff', 'beige'=>'#f5f5dc', 'bisque'=>'#ffe4c4', 'black'=>'#000000', 'blanchedalmond'=>'#ffebcd', 'blue'=>'#0000ff', 'blueviolet'=>'#8a2be2', 'brown'=>'#a52a2a', 'burlywood'=>'#deb887', 'cadetblue'=>'#5f9ea0', 'chartreuse'=>'#7fff00', 'chocolate'=>'#d2691e', 'coral'=>'#ff7f50', 'cornflowerblue'=>'#6495ed', 'cornsilk'=>'#fff8dc', 'crimson'=>'#dc143c', 'cyan'=>'#00ffff', 'darkblue'=>'#00008b', 'darkcyan'=>'#008b8b', 'darkgoldenrod'=>'#b8860b', 'darkgray'=>'#a9a9a9', 'darkgrey'=>'#a9a9a9', 'darkgreen'=>'#006400', 'darkkhaki'=>'#bdb76b', 'darkmagenta'=>'#8b008b', 'darkolivegreen'=>'#556b2f', 'darkorange'=>'#ff8c00', 'darkorchid'=>'#9932cc', 'darkred'=>'#8b0000', 'darksalmon'=>'#e9967a', 'darkseagreen'=>'#8fbc8f', 'darkslateblue'=>'#483d8b', 'darkslategray'=>'#2f4f4f', 'darkslategrey'=>'#2f4f4f', 'darkturquoise'=>'#00ced1', 'darkviolet'=>'#9400d3', 'deeppink'=>'#ff1493', 'deepskyblue'=>'#00bfff', 'dimgray'=>'#696969', 'dimgrey'=>'#696969', 'dodgerblue'=>'#1e90ff', 'firebrick'=>'#b22222', 'floralwhite'=>'#fffaf0', 'forestgreen'=>'#228b22', 'fuchsia'=>'#ff00ff', 'gainsboro'=>'#dcdcdc', 'ghostwhite'=>'#f8f8ff', 'gold'=>'#ffd700', 'goldenrod'=>'#daa520', 'gray'=>'#808080', 'grey'=>'#808080', 'green'=>'#008000', 'greenyellow'=>'#adff2f', 'honeydew'=>'#f0fff0', 'hotpink'=>'#ff69b4', 'indianred'=>'#cd5c5c', 'indigo'=>'#4b0082', 'ivory'=>'#fffff0', 'khaki'=>'#f0e68c', 'lavender'=>'#e6e6fa', 'lavenderblush'=>'#fff0f5', 'lawngreen'=>'#7cfc00', 'lemonchiffon'=>'#fffacd', 'lightblue'=>'#add8e6', 'lightcoral'=>'#f08080', 'lightcyan'=>'#e0ffff', 'lightgoldenrodyellow'=>'#fafad2', 'lightgray'=>'#d3d3d3', 'lightgrey'=>'#d3d3d3', 'lightgreen'=>'#90ee90', 'lightpink'=>'#ffb6c1', 'lightsalmon'=>'#ffa07a', 'lightseagreen'=>'#20b2aa', 'lightskyblue'=>'#87cefa', 'lightslategray'=>'#778899', 'lightslategrey'=>'#778899', 'lightsteelblue'=>'#b0c4de', 'lightyellow'=>'#ffffe0', 'lime'=>'#00ff00', 'limegreen'=>'#32cd32', 'linen'=>'#faf0e6', 'magenta'=>'#ff00ff', 'maroon'=>'#800000', 'mediumaquamarine'=>'#66cdaa', 'mediumblue'=>'#0000cd', 'mediumorchid'=>'#ba55d3', 'mediumpurple'=>'#9370d8', 'mediumseagreen'=>'#3cb371', 'mediumslateblue'=>'#7b68ee', 'mediumspringgreen'=>'#00fa9a', 'mediumturquoise'=>'#48d1cc', 'mediumvioletred'=>'#c71585', 'midnightblue'=>'#191970', 'mintcream'=>'#f5fffa', 'mistyrose'=>'#ffe4e1', 'moccasin'=>'#ffe4b5', 'navajowhite'=>'#ffdead', 'navy'=>'#000080', 'oldlace'=>'#fdf5e6', 'olive'=>'#808000', 'olivedrab'=>'#6b8e23', 'orange'=>'#ffa500', 'orangered'=>'#ff4500', 'orchid'=>'#da70d6', 'palegoldenrod'=>'#eee8aa', 'palegreen'=>'#98fb98', 'paleturquoise'=>'#afeeee', 'palevioletred'=>'#d87093', 'papayawhip'=>'#ffefd5', 'peachpuff'=>'#ffdab9', 'peru'=>'#cd853f', 'pink'=>'#ffc0cb', 'plum'=>'#dda0dd', 'powderblue'=>'#b0e0e6', 'purple'=>'#800080', 'red'=>'#ff0000', 'rosybrown'=>'#bc8f8f', 'royalblue'=>'#4169e1', 'saddlebrown'=>'#8b4513', 'salmon'=>'#fa8072', 'sandybrown'=>'#f4a460', 'seagreen'=>'#2e8b57', 'seashell'=>'#fff5ee', 'sienna'=>'#a0522d', 'silver'=>'#c0c0c0', 'skyblue'=>'#87ceeb', 'slateblue'=>'#6a5acd', 'slategray'=>'#708090', 'slategrey'=>'#708090', 'snow'=>'#fffafa', 'springgreen'=>'#00ff7f', 'steelblue'=>'#4682b4', 'tan'=>'#d2b48c', 'teal'=>'#008080', 'thistle'=>'#d8bfd8', 'tomato'=>'#ff6347', 'turquoise'=>'#40e0d0', 'violet'=>'#ee82ee', 'wheat'=>'#f5deb3', 'white'=>'#ffffff', 'whitesmoke'=>'#f5f5f5', 'yellow'=>'#ffff00', 'yellowgreen'=>'#9acd32' ); public static function hasOwnProperty($color) { return isset(self::$colors[$color]); } public static function color($color) { return self::$colors[$color]; } } class Less_Environment{ public $currentFileInfo; public $importMultiple = false; public $frames = array(); public $mediaBlocks = array(); public $mediaPath = array(); public static $parensStack = 0; public static $tabLevel = 0; public static $lastRule = false; public static $_outputMap; public static $mixin_stack = 0; public $functions = array(); public function Init(){ self::$parensStack = 0; self::$tabLevel = 0; self::$lastRule = false; self::$mixin_stack = 0; if( Less_Parser::$options['compress'] ){ Less_Environment::$_outputMap = array( ',' => ',', ': ' => ':', '' => '', ' ' => ' ', ':' => ' :', '+' => '+', '~' => '~', '>' => '>', '|' => '|', '^' => '^', '^^' => '^^' ); }else{ Less_Environment::$_outputMap = array( ',' => ', ', ': ' => ': ', '' => '', ' ' => ' ', ':' => ' :', '+' => ' + ', '~' => ' ~ ', '>' => ' > ', '|' => '|', '^' => ' ^ ', '^^' => ' ^^ ' ); } } public function copyEvalEnv($frames = array() ){ $new_env = new Less_Environment(); $new_env->frames = $frames; return $new_env; } public static function isMathOn(){ return !Less_Parser::$options['strictMath'] || Less_Environment::$parensStack; } public static function isPathRelative($path){ return !preg_match('/^(?:[a-z-]+:|\/)/',$path); } public static function normalizePath($path){ $segments = explode('/',$path); $segments = array_reverse($segments); $path = array(); $path_len = 0; while( $segments ){ $segment = array_pop($segments); switch( $segment ) { case '.': break; case '..': if( !$path_len || ( $path[$path_len-1] === '..') ){ $path[] = $segment; $path_len++; }else{ array_pop($path); $path_len--; } break; default: $path[] = $segment; $path_len++; break; } } return implode('/',$path); } public function unshiftFrame($frame){ array_unshift($this->frames, $frame); } public function shiftFrame(){ return array_shift($this->frames); } } class Less_Functions{ public $env; public $currentFileInfo; function __construct($env, $currentFileInfo = null ){ $this->env = $env; $this->currentFileInfo = $currentFileInfo; } public static function operate( $op, $a, $b ){ switch ($op) { case '+': return $a + $b; case '-': return $a - $b; case '*': return $a * $b; case '/': return $a / $b; } } public static function clamp($val, $max = 1){ return min( max($val, 0), $max); } public static function fround( $value ){ if( $value === 0 ){ return $value; } if( Less_Parser::$options['numPrecision'] ){ $p = pow(10, Less_Parser::$options['numPrecision']); return round( $value * $p) / $p; } return $value; } public static function number($n){ if ($n instanceof Less_Tree_Dimension) { return floatval( $n->unit->is('%') ? $n->value / 100 : $n->value); } else if (is_numeric($n)) { return $n; } else { throw new Less_Exception_Compiler("color functions take numbers as parameters"); } } public static function scaled($n, $size = 255 ){ if( $n instanceof Less_Tree_Dimension && $n->unit->is('%') ){ return (float)$n->value * $size / 100; } else { return Less_Functions::number($n); } } public function rgb ($r = null, $g = null, $b = null){ if (is_null($r) || is_null($g) || is_null($b)) { throw new Less_Exception_Compiler("rgb expects three parameters"); } return $this->rgba($r, $g, $b, 1.0); } public function rgba($r = null, $g = null, $b = null, $a = null){ $rgb = array($r, $g, $b); $rgb = array_map(array('Less_Functions','scaled'),$rgb); $a = self::number($a); return new Less_Tree_Color($rgb, $a); } public function hsl($h, $s, $l){ return $this->hsla($h, $s, $l, 1.0); } public function hsla($h, $s, $l, $a){ $h = fmod(self::number($h), 360) / 360; $s = self::clamp(self::number($s)); $l = self::clamp(self::number($l)); $a = self::clamp(self::number($a)); $m2 = $l <= 0.5 ? $l * ($s + 1) : $l + $s - $l * $s; $m1 = $l * 2 - $m2; return $this->rgba( self::hsla_hue($h + 1/3, $m1, $m2) * 255, self::hsla_hue($h, $m1, $m2) * 255, self::hsla_hue($h - 1/3, $m1, $m2) * 255, $a); } public function hsla_hue($h, $m1, $m2){ $h = $h < 0 ? $h + 1 : ($h > 1 ? $h - 1 : $h); if ($h * 6 < 1) return $m1 + ($m2 - $m1) * $h * 6; else if ($h * 2 < 1) return $m2; else if ($h * 3 < 2) return $m1 + ($m2 - $m1) * (2/3 - $h) * 6; else return $m1; } public function hsv($h, $s, $v) { return $this->hsva($h, $s, $v, 1.0); } public function hsva($h, $s, $v, $a) { $h = ((Less_Functions::number($h) % 360) / 360 ) * 360; $s = Less_Functions::number($s); $v = Less_Functions::number($v); $a = Less_Functions::number($a); $i = floor(($h / 60) % 6); $f = ($h / 60) - $i; $vs = array( $v, $v * (1 - $s), $v * (1 - $f * $s), $v * (1 - (1 - $f) * $s)); $perm = array(array(0, 3, 1), array(2, 0, 1), array(1, 0, 3), array(1, 2, 0), array(3, 1, 0), array(0, 1, 2)); return $this->rgba($vs[$perm[$i][0]] * 255, $vs[$perm[$i][1]] * 255, $vs[$perm[$i][2]] * 255, $a); } public function hue($color = null){ if (!$color instanceof Less_Tree_Color) { throw new Less_Exception_Compiler('The first argument to hue must be a color' . ($color instanceof Less_Tree_Expression ? ' (did you forgot commas?)' : '') ); } $c = $color->toHSL(); return new Less_Tree_Dimension(Less_Parser::round($c['h'])); } public function saturation($color = null){ if (!$color instanceof Less_Tree_Color) { throw new Less_Exception_Compiler('The first argument to saturation must be a color' . ($color instanceof Less_Tree_Expression ? ' (did you forgot commas?)' : '') ); } $c = $color->toHSL(); return new Less_Tree_Dimension(Less_Parser::round($c['s'] * 100), '%'); } public function lightness($color = null){ if (!$color instanceof Less_Tree_Color) { throw new Less_Exception_Compiler('The first argument to lightness must be a color' . ($color instanceof Less_Tree_Expression ? ' (did you forgot commas?)' : '') ); } $c = $color->toHSL(); return new Less_Tree_Dimension(Less_Parser::round($c['l'] * 100), '%'); } public function hsvhue( $color = null ){ if (!$color instanceof Less_Tree_Color) { throw new Less_Exception_Compiler('The first argument to hsvhue must be a color' . ($color instanceof Less_Tree_Expression ? ' (did you forgot commas?)' : '') ); } $hsv = $color->toHSV(); return new Less_Tree_Dimension( Less_Parser::round($hsv['h']) ); } public function hsvsaturation( $color = null ){ if (!$color instanceof Less_Tree_Color) { throw new Less_Exception_Compiler('The first argument to hsvsaturation must be a color' . ($color instanceof Less_Tree_Expression ? ' (did you forgot commas?)' : '') ); } $hsv = $color->toHSV(); return new Less_Tree_Dimension( Less_Parser::round($hsv['s'] * 100), '%' ); } public function hsvvalue( $color = null ){ if (!$color instanceof Less_Tree_Color) { throw new Less_Exception_Compiler('The first argument to hsvvalue must be a color' . ($color instanceof Less_Tree_Expression ? ' (did you forgot commas?)' : '') ); } $hsv = $color->toHSV(); return new Less_Tree_Dimension( Less_Parser::round($hsv['v'] * 100), '%' ); } public function red($color = null) { if (!$color instanceof Less_Tree_Color) { throw new Less_Exception_Compiler('The first argument to red must be a color' . ($color instanceof Less_Tree_Expression ? ' (did you forgot commas?)' : '') ); } return new Less_Tree_Dimension( $color->rgb[0] ); } public function green($color = null) { if (!$color instanceof Less_Tree_Color) { throw new Less_Exception_Compiler('The first argument to green must be a color' . ($color instanceof Less_Tree_Expression ? ' (did you forgot commas?)' : '') ); } return new Less_Tree_Dimension( $color->rgb[1] ); } public function blue($color = null) { if (!$color instanceof Less_Tree_Color) { throw new Less_Exception_Compiler('The first argument to blue must be a color' . ($color instanceof Less_Tree_Expression ? ' (did you forgot commas?)' : '') ); } return new Less_Tree_Dimension( $color->rgb[2] ); } public function alpha($color = null){ if (!$color instanceof Less_Tree_Color) { throw new Less_Exception_Compiler('The first argument to alpha must be a color' . ($color instanceof Less_Tree_Expression ? ' (did you forgot commas?)' : '') ); } $c = $color->toHSL(); return new Less_Tree_Dimension($c['a']); } public function luma ($color = null) { if (!$color instanceof Less_Tree_Color) { throw new Less_Exception_Compiler('The first argument to luma must be a color' . ($color instanceof Less_Tree_Expression ? ' (did you forgot commas?)' : '') ); } return new Less_Tree_Dimension(Less_Parser::round( $color->luma() * $color->alpha * 100), '%'); } public function luminance( $color = null ){ if (!$color instanceof Less_Tree_Color) { throw new Less_Exception_Compiler('The first argument to luminance must be a color' . ($color instanceof Less_Tree_Expression ? ' (did you forgot commas?)' : '') ); } $luminance = (0.2126 * $color->rgb[0] / 255) + (0.7152 * $color->rgb[1] / 255) + (0.0722 * $color->rgb[2] / 255); return new Less_Tree_Dimension(Less_Parser::round( $luminance * $color->alpha * 100), '%'); } public function saturate($color = null, $amount = null){ if ($color instanceof Less_Tree_Dimension) { return null; } if (!$color instanceof Less_Tree_Color) { throw new Less_Exception_Compiler('The first argument to saturate must be a color' . ($color instanceof Less_Tree_Expression ? ' (did you forgot commas?)' : '') ); } if (!$amount instanceof Less_Tree_Dimension) { throw new Less_Exception_Compiler('The second argument to saturate must be a percentage' . ($amount instanceof Less_Tree_Expression ? ' (did you forgot commas?)' : '') ); } $hsl = $color->toHSL(); $hsl['s'] += $amount->value / 100; $hsl['s'] = self::clamp($hsl['s']); return $this->hsla($hsl['h'], $hsl['s'], $hsl['l'], $hsl['a']); } public function desaturate($color = null, $amount = null){ if (!$color instanceof Less_Tree_Color) { throw new Less_Exception_Compiler('The first argument to desaturate must be a color' . ($color instanceof Less_Tree_Expression ? ' (did you forgot commas?)' : '') ); } if (!$amount instanceof Less_Tree_Dimension) { throw new Less_Exception_Compiler('The second argument to desaturate must be a percentage' . ($amount instanceof Less_Tree_Expression ? ' (did you forgot commas?)' : '') ); } $hsl = $color->toHSL(); $hsl['s'] -= $amount->value / 100; $hsl['s'] = self::clamp($hsl['s']); return $this->hsla($hsl['h'], $hsl['s'], $hsl['l'], $hsl['a']); } public function lighten($color = null, $amount=null){ if (!$color instanceof Less_Tree_Color) { throw new Less_Exception_Compiler('The first argument to lighten must be a color' . ($color instanceof Less_Tree_Expression ? ' (did you forgot commas?)' : '') ); } if (!$amount instanceof Less_Tree_Dimension) { throw new Less_Exception_Compiler('The second argument to lighten must be a percentage' . ($amount instanceof Less_Tree_Expression ? ' (did you forgot commas?)' : '') ); } $hsl = $color->toHSL(); $hsl['l'] += $amount->value / 100; $hsl['l'] = self::clamp($hsl['l']); return $this->hsla($hsl['h'], $hsl['s'], $hsl['l'], $hsl['a']); } public function darken($color = null, $amount = null){ if (!$color instanceof Less_Tree_Color) { throw new Less_Exception_Compiler('The first argument to darken must be a color' . ($color instanceof Less_Tree_Expression ? ' (did you forgot commas?)' : '') ); } if (!$amount instanceof Less_Tree_Dimension) { throw new Less_Exception_Compiler('The second argument to darken must be a percentage' . ($amount instanceof Less_Tree_Expression ? ' (did you forgot commas?)' : '') ); } $hsl = $color->toHSL(); $hsl['l'] -= $amount->value / 100; $hsl['l'] = self::clamp($hsl['l']); return $this->hsla($hsl['h'], $hsl['s'], $hsl['l'], $hsl['a']); } public function fadein($color = null, $amount = null){ if (!$color instanceof Less_Tree_Color) { throw new Less_Exception_Compiler('The first argument to fadein must be a color' . ($color instanceof Less_Tree_Expression ? ' (did you forgot commas?)' : '') ); } if (!$amount instanceof Less_Tree_Dimension) { throw new Less_Exception_Compiler('The second argument to fadein must be a percentage' . ($amount instanceof Less_Tree_Expression ? ' (did you forgot commas?)' : '') ); } $hsl = $color->toHSL(); $hsl['a'] += $amount->value / 100; $hsl['a'] = self::clamp($hsl['a']); return $this->hsla($hsl['h'], $hsl['s'], $hsl['l'], $hsl['a']); } public function fadeout($color = null, $amount = null){ if (!$color instanceof Less_Tree_Color) { throw new Less_Exception_Compiler('The first argument to fadeout must be a color' . ($color instanceof Less_Tree_Expression ? ' (did you forgot commas?)' : '') ); } if (!$amount instanceof Less_Tree_Dimension) { throw new Less_Exception_Compiler('The second argument to fadeout must be a percentage' . ($amount instanceof Less_Tree_Expression ? ' (did you forgot commas?)' : '') ); } $hsl = $color->toHSL(); $hsl['a'] -= $amount->value / 100; $hsl['a'] = self::clamp($hsl['a']); return $this->hsla($hsl['h'], $hsl['s'], $hsl['l'], $hsl['a']); } public function fade($color = null, $amount = null){ if (!$color instanceof Less_Tree_Color) { throw new Less_Exception_Compiler('The first argument to fade must be a color' . ($color instanceof Less_Tree_Expression ? ' (did you forgot commas?)' : '') ); } if (!$amount instanceof Less_Tree_Dimension) { throw new Less_Exception_Compiler('The second argument to fade must be a percentage' . ($amount instanceof Less_Tree_Expression ? ' (did you forgot commas?)' : '') ); } $hsl = $color->toHSL(); $hsl['a'] = $amount->value / 100; $hsl['a'] = self::clamp($hsl['a']); return $this->hsla($hsl['h'], $hsl['s'], $hsl['l'], $hsl['a']); } public function spin($color = null, $amount = null){ if (!$color instanceof Less_Tree_Color) { throw new Less_Exception_Compiler('The first argument to spin must be a color' . ($color instanceof Less_Tree_Expression ? ' (did you forgot commas?)' : '') ); } if (!$amount instanceof Less_Tree_Dimension) { throw new Less_Exception_Compiler('The second argument to spin must be a number' . ($amount instanceof Less_Tree_Expression ? ' (did you forgot commas?)' : '') ); } $hsl = $color->toHSL(); $hue = fmod($hsl['h'] + $amount->value, 360); $hsl['h'] = $hue < 0 ? 360 + $hue : $hue; return $this->hsla($hsl['h'], $hsl['s'], $hsl['l'], $hsl['a']); } public function mix($color1 = null, $color2 = null, $weight = null){ if (!$color1 instanceof Less_Tree_Color) { throw new Less_Exception_Compiler('The first argument to mix must be a color' . ($color1 instanceof Less_Tree_Expression ? ' (did you forgot commas?)' : '') ); } if (!$color2 instanceof Less_Tree_Color) { throw new Less_Exception_Compiler('The second argument to mix must be a color' . ($color2 instanceof Less_Tree_Expression ? ' (did you forgot commas?)' : '') ); } if (!$weight) { $weight = new Less_Tree_Dimension('50', '%'); } if (!$weight instanceof Less_Tree_Dimension) { throw new Less_Exception_Compiler('The third argument to contrast must be a percentage' . ($weight instanceof Less_Tree_Expression ? ' (did you forgot commas?)' : '') ); } $p = $weight->value / 100.0; $w = $p * 2 - 1; $hsl1 = $color1->toHSL(); $hsl2 = $color2->toHSL(); $a = $hsl1['a'] - $hsl2['a']; $w1 = (((($w * $a) == -1) ? $w : ($w + $a) / (1 + $w * $a)) + 1) / 2; $w2 = 1 - $w1; $rgb = array($color1->rgb[0] * $w1 + $color2->rgb[0] * $w2, $color1->rgb[1] * $w1 + $color2->rgb[1] * $w2, $color1->rgb[2] * $w1 + $color2->rgb[2] * $w2); $alpha = $color1->alpha * $p + $color2->alpha * (1 - $p); return new Less_Tree_Color($rgb, $alpha); } public function greyscale($color){ return $this->desaturate($color, new Less_Tree_Dimension(100,'%')); } public function contrast( $color, $dark = null, $light = null, $threshold = null){ if (!$color instanceof Less_Tree_Color) { return null; } if( !$light ){ $light = $this->rgba(255, 255, 255, 1.0); } if( !$dark ){ $dark = $this->rgba(0, 0, 0, 1.0); } if (!$dark instanceof Less_Tree_Color) { throw new Less_Exception_Compiler('The second argument to contrast must be a color' . ($dark instanceof Less_Tree_Expression ? ' (did you forgot commas?)' : '') ); } if (!$light instanceof Less_Tree_Color) { throw new Less_Exception_Compiler('The third argument to contrast must be a color' . ($light instanceof Less_Tree_Expression ? ' (did you forgot commas?)' : '') ); } if( $dark->luma() > $light->luma() ){ $t = $light; $light = $dark; $dark = $t; } if( !$threshold ){ $threshold = 0.43; } else { $threshold = Less_Functions::number($threshold); } if( $color->luma() < $threshold ){ return $light; } else { return $dark; } } public function e ($str){ if( is_string($str) ){ return new Less_Tree_Anonymous($str); } return new Less_Tree_Anonymous($str instanceof Less_Tree_JavaScript ? $str->expression : $str->value); } public function escape ($str){ $revert = array('%21'=>'!', '%2A'=>'*', '%27'=>"'",'%3F'=>'?','%26'=>'&','%2C'=>',','%2F'=>'/','%40'=>'@','%2B'=>'+','%24'=>'$'); return new Less_Tree_Anonymous(strtr(rawurlencode($str->value), $revert)); } public function replace( $string, $pattern, $replacement, $flags = null ){ $result = $string->value; $expr = '/'.str_replace('/','\\/',$pattern->value).'/'; if( $flags && $flags->value){ $expr .= self::replace_flags($flags->value); } $result = preg_replace($expr,$replacement->value,$result); if( property_exists($string,'quote') ){ return new Less_Tree_Quoted( $string->quote, $result, $string->escaped); } return new Less_Tree_Quoted( '', $result ); } public static function replace_flags($flags){ $flags = str_split($flags,1); $new_flags = ''; foreach($flags as $flag){ switch($flag){ case 'e': case 'g': break; default: $new_flags .= $flag; break; } } return $new_flags; } public function _percent(){ $string = func_get_arg(0); $args = func_get_args(); array_shift($args); $result = $string->value; foreach($args as $arg){ if( preg_match('/%[sda]/i',$result, $token) ){ $token = $token[0]; $value = stristr($token, 's') ? $arg->value : $arg->toCSS(); $value = preg_match('/[A-Z]$/', $token) ? urlencode($value) : $value; $result = preg_replace('/%[sda]/i',$value, $result, 1); } } $result = str_replace('%%', '%', $result); return new Less_Tree_Quoted( $string->quote , $result, $string->escaped); } public function unit( $val, $unit = null) { if( !($val instanceof Less_Tree_Dimension) ){ throw new Less_Exception_Compiler('The first argument to unit must be a number' . ($val instanceof Less_Tree_Operation ? '. Have you forgotten parenthesis?' : '.') ); } if( $unit ){ if( $unit instanceof Less_Tree_Keyword ){ $unit = $unit->value; } else { $unit = $unit->toCSS(); } } else { $unit = ""; } return new Less_Tree_Dimension($val->value, $unit ); } public function convert($val, $unit){ return $val->convertTo($unit->value); } public function round($n, $f = false) { $fraction = 0; if( $f !== false ){ $fraction = $f->value; } return $this->_math('Less_Parser::round',null, $n, $fraction); } public function pi(){ return new Less_Tree_Dimension(M_PI); } public function mod($a, $b) { return new Less_Tree_Dimension( $a->value % $b->value, $a->unit); } public function pow($x, $y) { if( is_numeric($x) && is_numeric($y) ){ $x = new Less_Tree_Dimension($x); $y = new Less_Tree_Dimension($y); }elseif( !($x instanceof Less_Tree_Dimension) || !($y instanceof Less_Tree_Dimension) ){ throw new Less_Exception_Compiler('Arguments must be numbers'); } return new Less_Tree_Dimension( pow($x->value, $y->value), $x->unit ); } public function ceil( $n ){ return $this->_math('ceil', null, $n); } public function floor( $n ){ return $this->_math('floor', null, $n); } public function sqrt( $n ){ return $this->_math('sqrt', null, $n); } public function abs( $n ){ return $this->_math('abs', null, $n); } public function tan( $n ){ return $this->_math('tan', '', $n); } public function sin( $n ){ return $this->_math('sin', '', $n); } public function cos( $n ){ return $this->_math('cos', '', $n); } public function atan( $n ){ return $this->_math('atan', 'rad', $n); } public function asin( $n ){ return $this->_math('asin', 'rad', $n); } public function acos( $n ){ return $this->_math('acos', 'rad', $n); } private function _math() { $args = func_get_args(); $fn = array_shift($args); $unit = array_shift($args); if ($args[0] instanceof Less_Tree_Dimension) { if( $unit === null ){ $unit = $args[0]->unit; }else{ $args[0] = $args[0]->unify(); } $args[0] = (float)$args[0]->value; return new Less_Tree_Dimension( call_user_func_array($fn, $args), $unit); } else if (is_numeric($args[0])) { return call_user_func_array($fn,$args); } else { throw new Less_Exception_Compiler("math functions take numbers as parameters"); } } private function _minmax( $isMin, $args ){ $arg_count = count($args); if( $arg_count < 1 ){ throw new Less_Exception_Compiler( 'one or more arguments required'); } $j = null; $unitClone = null; $unitStatic = null; $order = array(); $values = array(); for( $i = 0; $i < $arg_count; $i++ ){ $current = $args[$i]; if( !($current instanceof Less_Tree_Dimension) ){ if( is_array($args[$i]->value) ){ $args[] = $args[$i]->value; } continue; } if( $current->unit->toString() === '' && !$unitClone ){ $temp = new Less_Tree_Dimension($current->value, $unitClone); $currentUnified = $temp->unify(); }else{ $currentUnified = $current->unify(); } if( $currentUnified->unit->toString() === "" && !$unitStatic ){ $unit = $unitStatic; }else{ $unit = $currentUnified->unit->toString(); } if( $unit !== '' && !$unitStatic || $unit !== '' && $order[0]->unify()->unit->toString() === "" ){ $unitStatic = $unit; } if( $unit != '' && !$unitClone ){ $unitClone = $current->unit->toString(); } if( isset($values['']) && $unit !== '' && $unit === $unitStatic ){ $j = $values['']; }elseif( isset($values[$unit]) ){ $j = $values[$unit]; }else{ if( $unitStatic && $unit !== $unitStatic ){ throw new Less_Exception_Compiler( 'incompatible types'); } $values[$unit] = count($order); $order[] = $current; continue; } if( $order[$j]->unit->toString() === "" && $unitClone ){ $temp = new Less_Tree_Dimension( $order[$j]->value, $unitClone); $referenceUnified = $temp->unify(); }else{ $referenceUnified = $order[$j]->unify(); } if( ($isMin && $currentUnified->value < $referenceUnified->value) || (!$isMin && $currentUnified->value > $referenceUnified->value) ){ $order[$j] = $current; } } if( count($order) == 1 ){ return $order[0]; } $args = array(); foreach($order as $a){ $args[] = $a->toCSS($this->env); } return new Less_Tree_Anonymous( ($isMin?'min(':'max(') . implode(Less_Environment::$_outputMap[','],$args).')'); } public function min(){ $args = func_get_args(); return $this->_minmax( true, $args ); } public function max(){ $args = func_get_args(); return $this->_minmax( false, $args ); } public function getunit($n){ return new Less_Tree_Anonymous($n->unit); } public function argb($color) { if (!$color instanceof Less_Tree_Color) { throw new Less_Exception_Compiler('The first argument to argb must be a color' . ($color instanceof Less_Tree_Expression ? ' (did you forgot commas?)' : '') ); } return new Less_Tree_Anonymous($color->toARGB()); } public function percentage($n) { return new Less_Tree_Dimension($n->value * 100, '%'); } public function color($n) { if( $n instanceof Less_Tree_Quoted ){ $colorCandidate = $n->value; $returnColor = Less_Tree_Color::fromKeyword($colorCandidate); if( $returnColor ){ return $returnColor; } if( preg_match('/^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})/',$colorCandidate) ){ return new Less_Tree_Color(substr($colorCandidate, 1)); } throw new Less_Exception_Compiler("argument must be a color keyword or 3/6 digit hex e.g. #FFF"); } else { throw new Less_Exception_Compiler("argument must be a string"); } } public function iscolor($n) { return $this->_isa($n, 'Less_Tree_Color'); } public function isnumber($n) { return $this->_isa($n, 'Less_Tree_Dimension'); } public function isstring($n) { return $this->_isa($n, 'Less_Tree_Quoted'); } public function iskeyword($n) { return $this->_isa($n, 'Less_Tree_Keyword'); } public function isurl($n) { return $this->_isa($n, 'Less_Tree_Url'); } public function ispixel($n) { return $this->isunit($n, 'px'); } public function ispercentage($n) { return $this->isunit($n, '%'); } public function isem($n) { return $this->isunit($n, 'em'); } public function isunit( $n, $unit ){ return ($n instanceof Less_Tree_Dimension) && $n->unit->is( ( property_exists($unit,'value') ? $unit->value : $unit) ) ? new Less_Tree_Keyword('true') : new Less_Tree_Keyword('false'); } private function _isa($n, $type) { return is_a($n, $type) ? new Less_Tree_Keyword('true') : new Less_Tree_Keyword('false'); } public function tint($color, $amount) { return $this->mix( $this->rgb(255,255,255), $color, $amount); } public function shade($color, $amount) { return $this->mix($this->rgb(0, 0, 0), $color, $amount); } public function extract($values, $index ){ $index = (int)$index->value - 1; if( property_exists($values,'value') && is_array($values->value) ){ if( isset($values->value[$index]) ){ return $values->value[$index]; } return null; }elseif( (int)$index === 0 ){ return $values; } return null; } public function length($values){ $n = (property_exists($values,'value') && is_array($values->value)) ? count($values->value) : 1; return new Less_Tree_Dimension($n); } public function datauri($mimetypeNode, $filePathNode = null ) { $filePath = ( $filePathNode ? $filePathNode->value : null ); $mimetype = $mimetypeNode->value; $args = 2; if( !$filePath ){ $filePath = $mimetype; $args = 1; } $filePath = str_replace('\\','/',$filePath); if( Less_Environment::isPathRelative($filePath) ){ if( Less_Parser::$options['relativeUrls'] ){ $temp = $this->currentFileInfo['currentDirectory']; } else { $temp = $this->currentFileInfo['entryPath']; } if( !empty($temp) ){ $filePath = Less_Environment::normalizePath(rtrim($temp,'/').'/'.$filePath); } } if( $args < 2 ){ $mimetype = Less_Mime::lookup($filePath); $charset = Less_Mime::charsets_lookup($mimetype); $useBase64 = !in_array($charset,array('US-ASCII', 'UTF-8')); if( $useBase64 ){ $mimetype .= ';base64'; } }else{ $useBase64 = preg_match('/;base64$/',$mimetype); } if( file_exists($filePath) ){ $buf = @file_get_contents($filePath); }else{ $buf = false; } $DATA_URI_MAX_KB = 32; $fileSizeInKB = round( strlen($buf) / 1024 ); if( $fileSizeInKB >= $DATA_URI_MAX_KB ){ $url = new Less_Tree_Url( ($filePathNode ? $filePathNode : $mimetypeNode), $this->currentFileInfo); return $url->compile($this); } if( $buf ){ $buf = $useBase64 ? base64_encode($buf) : rawurlencode($buf); $filePath = '"data:' . $mimetype . ',' . $buf . '"'; } return new Less_Tree_Url( new Less_Tree_Anonymous($filePath) ); } public function svggradient( $direction ){ $throw_message = 'svg-gradient expects direction, start_color [start_position], [color position,]..., end_color [end_position]'; $arguments = func_get_args(); if( count($arguments) < 3 ){ throw new Less_Exception_Compiler( $throw_message ); } $stops = array_slice($arguments,1); $gradientType = 'linear'; $rectangleDimension = 'x="0" y="0" width="1" height="1"'; $useBase64 = true; $directionValue = $direction->toCSS(); switch( $directionValue ){ case "to bottom": $gradientDirectionSvg = 'x1="0%" y1="0%" x2="0%" y2="100%"'; break; case "to right": $gradientDirectionSvg = 'x1="0%" y1="0%" x2="100%" y2="0%"'; break; case "to bottom right": $gradientDirectionSvg = 'x1="0%" y1="0%" x2="100%" y2="100%"'; break; case "to top right": $gradientDirectionSvg = 'x1="0%" y1="100%" x2="100%" y2="0%"'; break; case "ellipse": case "ellipse at center": $gradientType = "radial"; $gradientDirectionSvg = 'cx="50%" cy="50%" r="75%"'; $rectangleDimension = 'x="-50" y="-50" width="101" height="101"'; break; default: throw new Less_Exception_Compiler( "svg-gradient direction must be 'to bottom', 'to right', 'to bottom right', 'to top right' or 'ellipse at center'" ); } $returner = '<?xml version="1.0" ?>' . '<svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="100%" height="100%" viewBox="0 0 1 1" preserveAspectRatio="none">' . '<' . $gradientType . 'Gradient id="gradient" gradientUnits="userSpaceOnUse" ' . $gradientDirectionSvg . '>'; for( $i = 0; $i < count($stops); $i++ ){ if( is_object($stops[$i]) && property_exists($stops[$i],'value') ){ $color = $stops[$i]->value[0]; $position = $stops[$i]->value[1]; }else{ $color = $stops[$i]; $position = null; } if( !($color instanceof Less_Tree_Color) || (!(($i === 0 || $i+1 === count($stops)) && $position === null) && !($position instanceof Less_Tree_Dimension)) ){ throw new Less_Exception_Compiler( $throw_message ); } if( $position ){ $positionValue = $position->toCSS(); }elseif( $i === 0 ){ $positionValue = '0%'; }else{ $positionValue = '100%'; } $alpha = $color->alpha; $returner .= '<stop offset="' . $positionValue . '" stop-color="' . $color->toRGB() . '"' . ($alpha < 1 ? ' stop-opacity="' . $alpha . '"' : '') . '/>'; } $returner .= '</' . $gradientType . 'Gradient><rect ' . $rectangleDimension . ' fill="url(#gradient)" /></svg>'; if( $useBase64 ){ $returner = "'data:image/svg+xml;base64,".base64_encode($returner)."'"; }else{ $returner = "'data:image/svg+xml,".$returner."'"; } return new Less_Tree_URL( new Less_Tree_Anonymous( $returner ) ); } public static function encodeURIComponent($string){ $revert = array('%21' => '!', '%2A' => '*', '%27' => "'", '%28' => '(', '%29' => ')'); return strtr(rawurlencode($string), $revert); } public function colorBlend( $mode, $color1, $color2 ){ $ab = $color1->alpha; $as = $color2->alpha; $r = array(); $ar = $as + $ab * (1 - $as); for( $i = 0; $i < 3; $i++ ){ $cb = $color1->rgb[$i] / 255; $cs = $color2->rgb[$i] / 255; $cr = call_user_func( $mode, $cb, $cs ); if( $ar ){ $cr = ($as * $cs + $ab * ($cb - $as * ($cb + $cs - $cr))) / $ar; } $r[$i] = $cr * 255; } return new Less_Tree_Color($r, $ar); } public function multiply($color1 = null, $color2 = null ){ if (!$color1 instanceof Less_Tree_Color) { throw new Less_Exception_Compiler('The first argument to multiply must be a color' . ($color1 instanceof Less_Tree_Expression ? ' (did you forgot commas?)' : '') ); } if (!$color2 instanceof Less_Tree_Color) { throw new Less_Exception_Compiler('The second argument to multiply must be a color' . ($color2 instanceof Less_Tree_Expression ? ' (did you forgot commas?)' : '') ); } return $this->colorBlend( array($this,'colorBlendMultiply'), $color1, $color2 ); } private function colorBlendMultiply($cb, $cs){ return $cb * $cs; } public function screen($color1 = null, $color2 = null ){ if (!$color1 instanceof Less_Tree_Color) { throw new Less_Exception_Compiler('The first argument to screen must be a color' . ($color1 instanceof Less_Tree_Expression ? ' (did you forgot commas?)' : '') ); } if (!$color2 instanceof Less_Tree_Color) { throw new Less_Exception_Compiler('The second argument to screen must be a color' . ($color2 instanceof Less_Tree_Expression ? ' (did you forgot commas?)' : '') ); } return $this->colorBlend( array($this,'colorBlendScreen'), $color1, $color2 ); } private function colorBlendScreen( $cb, $cs){ return $cb + $cs - $cb * $cs; } public function overlay($color1 = null, $color2 = null){ if (!$color1 instanceof Less_Tree_Color) { throw new Less_Exception_Compiler('The first argument to overlay must be a color' . ($color1 instanceof Less_Tree_Expression ? ' (did you forgot commas?)' : '') ); } if (!$color2 instanceof Less_Tree_Color) { throw new Less_Exception_Compiler('The second argument to overlay must be a color' . ($color2 instanceof Less_Tree_Expression ? ' (did you forgot commas?)' : '') ); } return $this->colorBlend( array($this,'colorBlendOverlay'), $color1, $color2 ); } private function colorBlendOverlay($cb, $cs ){ $cb *= 2; return ($cb <= 1) ? $this->colorBlendMultiply($cb, $cs) : $this->colorBlendScreen($cb - 1, $cs); } public function softlight($color1 = null, $color2 = null){ if (!$color1 instanceof Less_Tree_Color) { throw new Less_Exception_Compiler('The first argument to softlight must be a color' . ($color1 instanceof Less_Tree_Expression ? ' (did you forgot commas?)' : '') ); } if (!$color2 instanceof Less_Tree_Color) { throw new Less_Exception_Compiler('The second argument to softlight must be a color' . ($color2 instanceof Less_Tree_Expression ? ' (did you forgot commas?)' : '') ); } return $this->colorBlend( array($this,'colorBlendSoftlight'), $color1, $color2 ); } private function colorBlendSoftlight($cb, $cs ){ $d = 1; $e = $cb; if( $cs > 0.5 ){ $e = 1; $d = ($cb > 0.25) ? sqrt($cb) : ((16 * $cb - 12) * $cb + 4) * $cb; } return $cb - (1 - 2 * $cs) * $e * ($d - $cb); } public function hardlight($color1 = null, $color2 = null){ if (!$color1 instanceof Less_Tree_Color) { throw new Less_Exception_Compiler('The first argument to hardlight must be a color' . ($color1 instanceof Less_Tree_Expression ? ' (did you forgot commas?)' : '') ); } if (!$color2 instanceof Less_Tree_Color) { throw new Less_Exception_Compiler('The second argument to hardlight must be a color' . ($color2 instanceof Less_Tree_Expression ? ' (did you forgot commas?)' : '') ); } return $this->colorBlend( array($this,'colorBlendHardlight'), $color1, $color2 ); } private function colorBlendHardlight( $cb, $cs ){ return $this->colorBlendOverlay($cs, $cb); } public function difference($color1 = null, $color2 = null) { if (!$color1 instanceof Less_Tree_Color) { throw new Less_Exception_Compiler('The first argument to difference must be a color' . ($color1 instanceof Less_Tree_Expression ? ' (did you forgot commas?)' : '') ); } if (!$color2 instanceof Less_Tree_Color) { throw new Less_Exception_Compiler('The second argument to difference must be a color' . ($color2 instanceof Less_Tree_Expression ? ' (did you forgot commas?)' : '') ); } return $this->colorBlend( array($this,'colorBlendDifference'), $color1, $color2 ); } private function colorBlendDifference( $cb, $cs ){ return abs($cb - $cs); } public function exclusion( $color1 = null, $color2 = null ){ if (!$color1 instanceof Less_Tree_Color) { throw new Less_Exception_Compiler('The first argument to exclusion must be a color' . ($color1 instanceof Less_Tree_Expression ? ' (did you forgot commas?)' : '') ); } if (!$color2 instanceof Less_Tree_Color) { throw new Less_Exception_Compiler('The second argument to exclusion must be a color' . ($color2 instanceof Less_Tree_Expression ? ' (did you forgot commas?)' : '') ); } return $this->colorBlend( array($this,'colorBlendExclusion'), $color1, $color2 ); } private function colorBlendExclusion( $cb, $cs ){ return $cb + $cs - 2 * $cb * $cs; } public function average($color1 = null, $color2 = null){ if (!$color1 instanceof Less_Tree_Color) { throw new Less_Exception_Compiler('The first argument to average must be a color' . ($color1 instanceof Less_Tree_Expression ? ' (did you forgot commas?)' : '') ); } if (!$color2 instanceof Less_Tree_Color) { throw new Less_Exception_Compiler('The second argument to average must be a color' . ($color2 instanceof Less_Tree_Expression ? ' (did you forgot commas?)' : '') ); } return $this->colorBlend( array($this,'colorBlendAverage'), $color1, $color2 ); } public function colorBlendAverage($cb, $cs ){ return ($cb + $cs) / 2; } public function negation($color1 = null, $color2 = null ){ if (!$color1 instanceof Less_Tree_Color) { throw new Less_Exception_Compiler('The first argument to negation must be a color' . ($color1 instanceof Less_Tree_Expression ? ' (did you forgot commas?)' : '') ); } if (!$color2 instanceof Less_Tree_Color) { throw new Less_Exception_Compiler('The second argument to negation must be a color' . ($color2 instanceof Less_Tree_Expression ? ' (did you forgot commas?)' : '') ); } return $this->colorBlend( array($this,'colorBlendNegation'), $color1, $color2 ); } public function colorBlendNegation($cb, $cs){ return 1 - abs($cb + $cs - 1); } } class Less_Mime{ static $_types = array( '.htm' => 'text/html', '.html'=> 'text/html', '.gif' => 'image/gif', '.jpg' => 'image/jpeg', '.jpeg'=> 'image/jpeg', '.png' => 'image/png', '.ttf' => 'application/x-font-ttf', '.otf' => 'application/x-font-otf', '.eot' => 'application/vnd.ms-fontobject', '.woff' => 'application/x-font-woff', '.svg' => 'image/svg+xml', ); public static function lookup( $filepath ){ $parts = explode('.',$filepath); $ext = '.'.strtolower(array_pop($parts)); if( !isset(self::$_types[$ext]) ){ return null; } return self::$_types[$ext]; } public static function charsets_lookup( $type = null ){ return $type && preg_match('/^text\//',$type) ? 'UTF-8' : ''; } } class Less_Tree{ public $cache_string; public function toCSS(){ $output = new Less_Output(); $this->genCSS($output); return $output->toString(); } public function genCSS($output){} public static function outputRuleset( $output, $rules ){ $ruleCnt = count($rules); Less_Environment::$tabLevel++; if( Less_Parser::$options['compress'] ){ $output->add('{'); for( $i = 0; $i < $ruleCnt; $i++ ){ $rules[$i]->genCSS( $output ); } $output->add( '}' ); Less_Environment::$tabLevel--; return; } $tabSetStr = "\n".str_repeat( Less_Parser::$options['indentation'] , Less_Environment::$tabLevel-1 ); $tabRuleStr = $tabSetStr.Less_Parser::$options['indentation']; $output->add( " {" ); for($i = 0; $i < $ruleCnt; $i++ ){ $output->add( $tabRuleStr ); $rules[$i]->genCSS( $output ); } Less_Environment::$tabLevel--; $output->add( $tabSetStr.'}' ); } public function accept($visitor){} public static function ReferencedArray($rules){ foreach($rules as $rule){ if( method_exists($rule, 'markReferenced') ){ $rule->markReferenced(); } } } public static function __set_state($args){ $class = get_called_class(); $obj = new $class(null,null,null,null); foreach($args as $key => $val){ $obj->$key = $val; } return $obj; } } class Less_Output{ protected $strs = array(); public function add($chunk, $fileInfo = null, $index = 0, $mapLines = null){ $this->strs[] = $chunk; } public function isEmpty(){ return count($this->strs) === 0; } public function toString(){ return implode('',$this->strs); } } class Less_Visitor{ protected $methods = array(); protected $_visitFnCache = array(); public function __construct(){ $this->_visitFnCache = get_class_methods(get_class($this)); $this->_visitFnCache = array_flip($this->_visitFnCache); } public function visitObj( $node ){ $funcName = 'visit'.$node->type; if( isset($this->_visitFnCache[$funcName]) ){ $visitDeeper = true; $this->$funcName( $node, $visitDeeper ); if( $visitDeeper ){ $node->accept($this); } $funcName = $funcName . "Out"; if( isset($this->_visitFnCache[$funcName]) ){ $this->$funcName( $node ); } }else{ $node->accept($this); } return $node; } public function visitArray( $nodes ){ array_map( array($this,'visitObj'), $nodes); return $nodes; } } class Less_VisitorReplacing extends Less_Visitor{ public function visitObj( $node ){ $funcName = 'visit'.$node->type; if( isset($this->_visitFnCache[$funcName]) ){ $visitDeeper = true; $node = $this->$funcName( $node, $visitDeeper ); if( $node ){ if( $visitDeeper && is_object($node) ){ $node->accept($this); } $funcName = $funcName . "Out"; if( isset($this->_visitFnCache[$funcName]) ){ $this->$funcName( $node ); } } }else{ $node->accept($this); } return $node; } public function visitArray( $nodes ){ $newNodes = array(); foreach($nodes as $node){ $evald = $this->visitObj($node); if( $evald ){ if( is_array($evald) ){ self::flatten($evald,$newNodes); }else{ $newNodes[] = $evald; } } } return $newNodes; } public function flatten( $arr, &$out ){ foreach($arr as $item){ if( !is_array($item) ){ $out[] = $item; continue; } foreach($item as $nestedItem){ if( is_array($nestedItem) ){ self::flatten( $nestedItem, $out); }else{ $out[] = $nestedItem; } } } return $out; } } abstract class Less_Configurable { protected $options = array(); protected $defaultOptions = array(); public function setOptions($options){ $options = array_intersect_key($options,$this->defaultOptions); $this->options = array_merge($this->defaultOptions, $this->options, $options); } public function getOption($name, $default = null){ if(isset($this->options[$name])){ return $this->options[$name]; } return $default; } public function setOption($name, $value){ $this->options[$name] = $value; } } class Less_Tree_Alpha extends Less_Tree{ public $value; public $type = 'Alpha'; public function __construct($val){ $this->value = $val; } public function compile($env){ if( is_object($this->value) ){ $this->value = $this->value->compile($env); } return $this; } public function genCSS( $output ){ $output->add( "alpha(opacity=" ); if( is_string($this->value) ){ $output->add( $this->value ); }else{ $this->value->genCSS( $output); } $output->add( ')' ); } public function toCSS(){ return "alpha(opacity=" . (is_string($this->value) ? $this->value : $this->value->toCSS()) . ")"; } } class Less_Tree_Anonymous extends Less_Tree{ public $value; public $quote; public $index; public $mapLines; public $currentFileInfo; public $type = 'Anonymous'; public function __construct($value, $index = null, $currentFileInfo = null, $mapLines = null ){ $this->value = $value; $this->index = $index; $this->mapLines = $mapLines; $this->currentFileInfo = $currentFileInfo; } public function compile(){ return new Less_Tree_Anonymous($this->value, $this->index, $this->currentFileInfo, $this->mapLines); } public function compare($x){ if( !is_object($x) ){ return -1; } $left = $this->toCSS(); $right = $x->toCSS(); if( $left === $right ){ return 0; } return $left < $right ? -1 : 1; } public function genCSS( $output ){ $output->add( $this->value, $this->currentFileInfo, $this->index, $this->mapLines ); } public function toCSS(){ return $this->value; } } class Less_Tree_Assignment extends Less_Tree{ public $key; public $value; public $type = 'Assignment'; public function __construct($key, $val) { $this->key = $key; $this->value = $val; } public function accept( $visitor ){ $this->value = $visitor->visitObj( $this->value ); } public function compile($env) { return new Less_Tree_Assignment( $this->key, $this->value->compile($env)); } public function genCSS( $output ){ $output->add( $this->key . '=' ); $this->value->genCSS( $output ); } public function toCss(){ return $this->key . '=' . $this->value->toCSS(); } } class Less_Tree_Attribute extends Less_Tree{ public $key; public $op; public $value; public $type = 'Attribute'; public function __construct($key, $op, $value){ $this->key = $key; $this->op = $op; $this->value = $value; } public function compile($env){ $key_obj = is_object($this->key); $val_obj = is_object($this->value); if( !$key_obj && !$val_obj ){ return $this; } return new Less_Tree_Attribute( $key_obj ? $this->key->compile($env) : $this->key , $this->op, $val_obj ? $this->value->compile($env) : $this->value); } public function genCSS( $output ){ $output->add( $this->toCSS() ); } public function toCSS(){ $value = $this->key; if( $this->op ){ $value .= $this->op; $value .= (is_object($this->value) ? $this->value->toCSS() : $this->value); } return '[' . $value . ']'; } } class Less_Tree_Call extends Less_Tree{ public $value; protected $name; protected $args; protected $index; protected $currentFileInfo; public $type = 'Call'; public function __construct($name, $args, $index, $currentFileInfo = null ){ $this->name = $name; $this->args = $args; $this->index = $index; $this->currentFileInfo = $currentFileInfo; } public function accept( $visitor ){ $this->args = $visitor->visitArray( $this->args ); } public function compile($env=null){ $args = array(); foreach($this->args as $a){ $args[] = $a->compile($env); } $nameLC = strtolower($this->name); switch($nameLC){ case '%': $nameLC = '_percent'; break; case 'get-unit': $nameLC = 'getunit'; break; case 'data-uri': $nameLC = 'datauri'; break; case 'svg-gradient': $nameLC = 'svggradient'; break; } $result = null; if( $nameLC === 'default' ){ $result = Less_Tree_DefaultFunc::compile(); }else{ if( method_exists('Less_Functions',$nameLC) ){ try { $func = new Less_Functions($env, $this->currentFileInfo); $result = call_user_func_array( array($func,$nameLC),$args); } catch (Exception $e) { throw new Less_Exception_Compiler('error evaluating function `' . $this->name . '` '.$e->getMessage().' index: '. $this->index); } } elseif( isset( $env->functions[$nameLC] ) && is_callable( $env->functions[$nameLC] ) ) { try { $result = call_user_func_array( $env->functions[$nameLC], $args ); } catch (Exception $e) { throw new Less_Exception_Compiler('error evaluating function `' . $this->name . '` '.$e->getMessage().' index: '. $this->index); } } } if( $result !== null ){ return $result; } return new Less_Tree_Call( $this->name, $args, $this->index, $this->currentFileInfo ); } public function genCSS( $output ){ $output->add( $this->name . '(', $this->currentFileInfo, $this->index ); $args_len = count($this->args); for($i = 0; $i < $args_len; $i++ ){ $this->args[$i]->genCSS( $output ); if( $i + 1 < $args_len ){ $output->add( ', ' ); } } $output->add( ')' ); } } class Less_Tree_Color extends Less_Tree{ public $rgb; public $alpha; public $isTransparentKeyword; public $type = 'Color'; public function __construct($rgb, $a = 1, $isTransparentKeyword = null ){ if( $isTransparentKeyword ){ $this->rgb = $rgb; $this->alpha = $a; $this->isTransparentKeyword = true; return; } $this->rgb = array(); if( is_array($rgb) ){ $this->rgb = $rgb; }else if( strlen($rgb) == 6 ){ foreach(str_split($rgb, 2) as $c){ $this->rgb[] = hexdec($c); } }else{ foreach(str_split($rgb, 1) as $c){ $this->rgb[] = hexdec($c.$c); } } $this->alpha = is_numeric($a) ? $a : 1; } public function compile(){ return $this; } public function luma(){ $r = $this->rgb[0] / 255; $g = $this->rgb[1] / 255; $b = $this->rgb[2] / 255; $r = ($r <= 0.03928) ? $r / 12.92 : pow((($r + 0.055) / 1.055), 2.4); $g = ($g <= 0.03928) ? $g / 12.92 : pow((($g + 0.055) / 1.055), 2.4); $b = ($b <= 0.03928) ? $b / 12.92 : pow((($b + 0.055) / 1.055), 2.4); return 0.2126 * $r + 0.7152 * $g + 0.0722 * $b; } public function genCSS( $output ){ $output->add( $this->toCSS() ); } public function toCSS( $doNotCompress = false ){ $compress = Less_Parser::$options['compress'] && !$doNotCompress; $alpha = Less_Functions::fround( $this->alpha ); if( $alpha < 1 ){ if( ( $alpha === 0 || $alpha === 0.0 ) && isset($this->isTransparentKeyword) && $this->isTransparentKeyword ){ return 'transparent'; } $values = array(); foreach($this->rgb as $c){ $values[] = Less_Functions::clamp( round($c), 255); } $values[] = $alpha; $glue = ($compress ? ',' : ', '); return "rgba(" . implode($glue, $values) . ")"; }else{ $color = $this->toRGB(); if( $compress ){ if( $color[1] === $color[2] && $color[3] === $color[4] && $color[5] === $color[6]) { $color = '#'.$color[1] . $color[3] . $color[5]; } } return $color; } } public function operate( $op, $other) { $rgb = array(); $alpha = $this->alpha * (1 - $other->alpha) + $other->alpha; for ($c = 0; $c < 3; $c++) { $rgb[$c] = Less_Functions::operate( $op, $this->rgb[$c], $other->rgb[$c]); } return new Less_Tree_Color($rgb, $alpha); } public function toRGB(){ return $this->toHex($this->rgb); } public function toHSL(){ $r = $this->rgb[0] / 255; $g = $this->rgb[1] / 255; $b = $this->rgb[2] / 255; $a = $this->alpha; $max = max($r, $g, $b); $min = min($r, $g, $b); $l = ($max + $min) / 2; $d = $max - $min; $h = $s = 0; if( $max !== $min ){ $s = $l > 0.5 ? $d / (2 - $max - $min) : $d / ($max + $min); switch ($max) { case $r: $h = ($g - $b) / $d + ($g < $b ? 6 : 0); break; case $g: $h = ($b - $r) / $d + 2; break; case $b: $h = ($r - $g) / $d + 4; break; } $h /= 6; } return array('h' => $h * 360, 's' => $s, 'l' => $l, 'a' => $a ); } public function toHSV() { $r = $this->rgb[0] / 255; $g = $this->rgb[1] / 255; $b = $this->rgb[2] / 255; $a = $this->alpha; $max = max($r, $g, $b); $min = min($r, $g, $b); $v = $max; $d = $max - $min; if ($max === 0) { $s = 0; } else { $s = $d / $max; } $h = 0; if( $max !== $min ){ switch($max){ case $r: $h = ($g - $b) / $d + ($g < $b ? 6 : 0); break; case $g: $h = ($b - $r) / $d + 2; break; case $b: $h = ($r - $g) / $d + 4; break; } $h /= 6; } return array('h'=> $h * 360, 's'=> $s, 'v'=> $v, 'a' => $a ); } public function toARGB(){ $argb = array_merge( (array) Less_Parser::round($this->alpha * 255), $this->rgb); return $this->toHex( $argb ); } public function compare($x){ if( !property_exists( $x, 'rgb' ) ){ return -1; } return ($x->rgb[0] === $this->rgb[0] && $x->rgb[1] === $this->rgb[1] && $x->rgb[2] === $this->rgb[2] && $x->alpha === $this->alpha) ? 0 : -1; } public function toHex( $v ){ $ret = '#'; foreach($v as $c){ $c = Less_Functions::clamp( Less_Parser::round($c), 255); if( $c < 16 ){ $ret .= '0'; } $ret .= dechex($c); } return $ret; } public static function fromKeyword( $keyword ){ $keyword = strtolower($keyword); if( Less_Colors::hasOwnProperty($keyword) ){ return new Less_Tree_Color(substr(Less_Colors::color($keyword), 1)); } if( $keyword === 'transparent' ){ return new Less_Tree_Color( array(0, 0, 0), 0, true); } } } class Less_Tree_Comment extends Less_Tree{ public $value; public $silent; public $isReferenced; public $currentFileInfo; public $type = 'Comment'; public function __construct($value, $silent, $index = null, $currentFileInfo = null ){ $this->value = $value; $this->silent = !! $silent; $this->currentFileInfo = $currentFileInfo; } public function genCSS( $output ){ $output->add( trim($this->value) ); } public function toCSS(){ return Less_Parser::$options['compress'] ? '' : $this->value; } public function isSilent(){ $isReference = ($this->currentFileInfo && isset($this->currentFileInfo['reference']) && (!isset($this->isReferenced) || !$this->isReferenced) ); $isCompressed = Less_Parser::$options['compress'] && !preg_match('/^\/\*!/', $this->value); return $this->silent || $isReference || $isCompressed; } public function compile(){ return $this; } public function markReferenced(){ $this->isReferenced = true; } } class Less_Tree_Condition extends Less_Tree{ public $op; public $lvalue; public $rvalue; public $index; public $negate; public $type = 'Condition'; public function __construct($op, $l, $r, $i = 0, $negate = false) { $this->op = trim($op); $this->lvalue = $l; $this->rvalue = $r; $this->index = $i; $this->negate = $negate; } public function accept($visitor){ $this->lvalue = $visitor->visitObj( $this->lvalue ); $this->rvalue = $visitor->visitObj( $this->rvalue ); } public function compile($env) { $a = $this->lvalue->compile($env); $b = $this->rvalue->compile($env); switch( $this->op ){ case 'and': $result = $a && $b; break; case 'or': $result = $a || $b; break; default: if( Less_Parser::is_method($a, 'compare') ){ $result = $a->compare($b); }elseif( Less_Parser::is_method($b, 'compare') ){ $result = $b->compare($a); }else{ throw new Less_Exception_Compiler('Unable to perform comparison', null, $this->index); } switch ($result) { case -1: $result = $this->op === '<' || $this->op === '=<' || $this->op === '<='; break; case 0: $result = $this->op === '=' || $this->op === '>=' || $this->op === '=<' || $this->op === '<='; break; case 1: $result = $this->op === '>' || $this->op === '>='; break; } break; } return $this->negate ? !$result : $result; } } class Less_Tree_DefaultFunc{ static $error_; static $value_; public static function compile(){ if( self::$error_ ){ throw new Exception(self::$error_); } if( self::$value_ !== null ){ return self::$value_ ? new Less_Tree_Keyword('true') : new Less_Tree_Keyword('false'); } } public static function value( $v ){ self::$value_ = $v; } public static function error( $e ){ self::$error_ = $e; } public static function reset(){ self::$value_ = self::$error_ = null; } } class Less_Tree_DetachedRuleset extends Less_Tree{ public $ruleset; public $frames; public $type = 'DetachedRuleset'; public function __construct( $ruleset, $frames = null ){ $this->ruleset = $ruleset; $this->frames = $frames; } public function accept($visitor) { $this->ruleset = $visitor->visitObj($this->ruleset); } public function compile($env){ if( $this->frames ){ $frames = $this->frames; }else{ $frames = $env->frames; } return new Less_Tree_DetachedRuleset($this->ruleset, $frames); } public function callEval($env) { if( $this->frames ){ return $this->ruleset->compile( $env->copyEvalEnv( array_merge($this->frames,$env->frames) ) ); } return $this->ruleset->compile( $env ); } } class Less_Tree_Dimension extends Less_Tree{ public $value; public $unit; public $type = 'Dimension'; public function __construct($value, $unit = null){ $this->value = floatval($value); if( $unit && ($unit instanceof Less_Tree_Unit) ){ $this->unit = $unit; }elseif( $unit ){ $this->unit = new Less_Tree_Unit( array($unit) ); }else{ $this->unit = new Less_Tree_Unit( ); } } public function accept( $visitor ){ $this->unit = $visitor->visitObj( $this->unit ); } public function compile(){ return $this; } public function toColor() { return new Less_Tree_Color(array($this->value, $this->value, $this->value)); } public function genCSS( $output ){ if( Less_Parser::$options['strictUnits'] && !$this->unit->isSingular() ){ throw new Less_Exception_Compiler("Multiple units in dimension. Correct the units or use the unit function. Bad unit: ".$this->unit->toString()); } $value = Less_Functions::fround( $this->value ); $strValue = (string)$value; if( $value !== 0 && $value < 0.000001 && $value > -0.000001 ){ $strValue = number_format($strValue,10); $strValue = preg_replace('/\.?0+$/','', $strValue); } if( Less_Parser::$options['compress'] ){ if( $value === 0 && $this->unit->isLength() ){ $output->add( $strValue ); return $strValue; } if( $value > 0 && $value < 1 && $strValue[0] === '0' ){ $strValue = substr($strValue,1); } } $output->add( $strValue ); $this->unit->genCSS( $output ); } public function __toString(){ return $this->toCSS(); } public function operate( $op, $other){ $value = Less_Functions::operate( $op, $this->value, $other->value); $unit = clone $this->unit; if( $op === '+' || $op === '-' ){ if( !$unit->numerator && !$unit->denominator ){ $unit->numerator = $other->unit->numerator; $unit->denominator = $other->unit->denominator; }elseif( !$other->unit->numerator && !$other->unit->denominator ){ }else{ $other = $other->convertTo( $this->unit->usedUnits()); if( Less_Parser::$options['strictUnits'] && $other->unit->toString() !== $unit->toCSS() ){ throw new Less_Exception_Compiler("Incompatible units. Change the units or use the unit function. Bad units: '" . $unit->toString() . "' and " . $other->unit->toString() . "'."); } $value = Less_Functions::operate( $op, $this->value, $other->value); } }elseif( $op === '*' ){ $unit->numerator = array_merge($unit->numerator, $other->unit->numerator); $unit->denominator = array_merge($unit->denominator, $other->unit->denominator); sort($unit->numerator); sort($unit->denominator); $unit->cancel(); }elseif( $op === '/' ){ $unit->numerator = array_merge($unit->numerator, $other->unit->denominator); $unit->denominator = array_merge($unit->denominator, $other->unit->numerator); sort($unit->numerator); sort($unit->denominator); $unit->cancel(); } return new Less_Tree_Dimension( $value, $unit); } public function compare($other) { if ($other instanceof Less_Tree_Dimension) { if( $this->unit->isEmpty() || $other->unit->isEmpty() ){ $a = $this; $b = $other; } else { $a = $this->unify(); $b = $other->unify(); if( $a->unit->compare($b->unit) !== 0 ){ return -1; } } $aValue = $a->value; $bValue = $b->value; if ($bValue > $aValue) { return -1; } elseif ($bValue < $aValue) { return 1; } else { return 0; } } else { return -1; } } public function unify() { return $this->convertTo(array('length'=> 'px', 'duration'=> 's', 'angle' => 'rad' )); } public function convertTo($conversions) { $value = $this->value; $unit = clone $this->unit; if( is_string($conversions) ){ $derivedConversions = array(); foreach( Less_Tree_UnitConversions::$groups as $i ){ if( isset(Less_Tree_UnitConversions::${$i}[$conversions]) ){ $derivedConversions = array( $i => $conversions); } } $conversions = $derivedConversions; } foreach($conversions as $groupName => $targetUnit){ $group = Less_Tree_UnitConversions::${$groupName}; foreach($unit->numerator as $i => $atomicUnit){ $atomicUnit = $unit->numerator[$i]; if( !isset($group[$atomicUnit]) ){ continue; } $value = $value * ($group[$atomicUnit] / $group[$targetUnit]); $unit->numerator[$i] = $targetUnit; } foreach($unit->denominator as $i => $atomicUnit){ $atomicUnit = $unit->denominator[$i]; if( !isset($group[$atomicUnit]) ){ continue; } $value = $value / ($group[$atomicUnit] / $group[$targetUnit]); $unit->denominator[$i] = $targetUnit; } } $unit->cancel(); return new Less_Tree_Dimension( $value, $unit); } } class Less_Tree_Directive extends Less_Tree{ public $name; public $value; public $rules; public $index; public $isReferenced; public $currentFileInfo; public $debugInfo; public $type = 'Directive'; public function __construct($name, $value = null, $rules, $index = null, $currentFileInfo = null, $debugInfo = null ){ $this->name = $name; $this->value = $value; if( $rules ){ $this->rules = $rules; $this->rules->allowImports = true; } $this->index = $index; $this->currentFileInfo = $currentFileInfo; $this->debugInfo = $debugInfo; } public function accept( $visitor ){ if( $this->rules ){ $this->rules = $visitor->visitObj( $this->rules ); } if( $this->value ){ $this->value = $visitor->visitObj( $this->value ); } } public function genCSS( $output ){ $value = $this->value; $rules = $this->rules; $output->add( $this->name, $this->currentFileInfo, $this->index ); if( $this->value ){ $output->add(' '); $this->value->genCSS($output); } if( $this->rules ){ Less_Tree::outputRuleset( $output, array($this->rules)); } else { $output->add(';'); } } public function compile($env){ $value = $this->value; $rules = $this->rules; if( $value ){ $value = $value->compile($env); } if( $rules ){ $rules = $rules->compile($env); $rules->root = true; } return new Less_Tree_Directive( $this->name, $value, $rules, $this->index, $this->currentFileInfo, $this->debugInfo ); } public function variable($name){ if( $this->rules ){ return $this->rules->variable($name); } } public function find($selector){ if( $this->rules ){ return $this->rules->find($selector, $this); } } public function markReferenced(){ $this->isReferenced = true; if( $this->rules ){ Less_Tree::ReferencedArray($this->rules->rules); } } } class Less_Tree_Element extends Less_Tree{ public $combinator = ''; public $value = ''; public $index; public $currentFileInfo; public $type = 'Element'; public $value_is_object = false; public function __construct($combinator, $value, $index = null, $currentFileInfo = null ){ $this->value = $value; $this->value_is_object = is_object($value); if( $combinator ){ $this->combinator = $combinator; } $this->index = $index; $this->currentFileInfo = $currentFileInfo; } public function accept( $visitor ){ if( $this->value_is_object ){ $this->value = $visitor->visitObj( $this->value ); } } public function compile($env){ if( Less_Environment::$mixin_stack ){ return new Less_Tree_Element($this->combinator, ($this->value_is_object ? $this->value->compile($env) : $this->value), $this->index, $this->currentFileInfo ); } if( $this->value_is_object ){ $this->value = $this->value->compile($env); } return $this; } public function genCSS( $output ){ $output->add( $this->toCSS(), $this->currentFileInfo, $this->index ); } public function toCSS(){ if( $this->value_is_object ){ $value = $this->value->toCSS(); }else{ $value = $this->value; } if( $value === '' && $this->combinator && $this->combinator === '&' ){ return ''; } return Less_Environment::$_outputMap[$this->combinator] . $value; } } class Less_Tree_Expression extends Less_Tree{ public $value = array(); public $parens = false; public $parensInOp = false; public $type = 'Expression'; public function __construct( $value, $parens = null ){ $this->value = $value; $this->parens = $parens; } public function accept( $visitor ){ $this->value = $visitor->visitArray( $this->value ); } public function compile($env) { $doubleParen = false; if( $this->parens && !$this->parensInOp ){ Less_Environment::$parensStack++; } $returnValue = null; if( $this->value ){ $count = count($this->value); if( $count > 1 ){ $ret = array(); foreach($this->value as $e){ $ret[] = $e->compile($env); } $returnValue = new Less_Tree_Expression($ret); }else{ if( ($this->value[0] instanceof Less_Tree_Expression) && $this->value[0]->parens && !$this->value[0]->parensInOp ){ $doubleParen = true; } $returnValue = $this->value[0]->compile($env); } } else { $returnValue = $this; } if( $this->parens ){ if( !$this->parensInOp ){ Less_Environment::$parensStack--; }elseif( !Less_Environment::isMathOn() && !$doubleParen ){ $returnValue = new Less_Tree_Paren($returnValue); } } return $returnValue; } public function genCSS( $output ){ $val_len = count($this->value); for( $i = 0; $i < $val_len; $i++ ){ $this->value[$i]->genCSS( $output ); if( $i + 1 < $val_len ){ $output->add( ' ' ); } } } public function throwAwayComments() { if( is_array($this->value) ){ $new_value = array(); foreach($this->value as $v){ if( $v instanceof Less_Tree_Comment ){ continue; } $new_value[] = $v; } $this->value = $new_value; } } } class Less_Tree_Extend extends Less_Tree{ public $selector; public $option; public $index; public $selfSelectors = array(); public $allowBefore; public $allowAfter; public $firstExtendOnThisSelectorPath; public $type = 'Extend'; public $ruleset; public $object_id; public $parent_ids = array(); public function __construct($selector, $option, $index){ static $i = 0; $this->selector = $selector; $this->option = $option; $this->index = $index; switch($option){ case "all": $this->allowBefore = true; $this->allowAfter = true; break; default: $this->allowBefore = false; $this->allowAfter = false; break; } $this->object_id = $i++; $this->parent_ids = array($this->object_id); } public function accept( $visitor ){ $this->selector = $visitor->visitObj( $this->selector ); } public function compile( $env ){ Less_Parser::$has_extends = true; $this->selector = $this->selector->compile($env); return $this; } public function findSelfSelectors( $selectors ){ $selfElements = array(); for( $i = 0, $selectors_len = count($selectors); $i < $selectors_len; $i++ ){ $selectorElements = $selectors[$i]->elements; if( $i && $selectorElements && $selectorElements[0]->combinator === "") { $selectorElements[0]->combinator = ' '; } $selfElements = array_merge( $selfElements, $selectors[$i]->elements ); } $this->selfSelectors = array(new Less_Tree_Selector($selfElements)); } } class Less_Tree_Import extends Less_Tree{ public $options; public $index; public $path; public $features; public $currentFileInfo; public $css; public $skip; public $root; public $type = 'Import'; public function __construct($path, $features, $options, $index, $currentFileInfo = null ){ $this->options = $options; $this->index = $index; $this->path = $path; $this->features = $features; $this->currentFileInfo = $currentFileInfo; if( is_array($options) ){ $this->options += array('inline'=>false); if( isset($this->options['less']) || $this->options['inline'] ){ $this->css = !isset($this->options['less']) || !$this->options['less'] || $this->options['inline']; } else { $pathValue = $this->getPath(); if( $pathValue && preg_match('/css([\?;].*)?$/',$pathValue) ){ $this->css = true; } } } } public function accept($visitor){ if( $this->features ){ $this->features = $visitor->visitObj($this->features); } $this->path = $visitor->visitObj($this->path); if( !$this->options['inline'] && $this->root ){ $this->root = $visitor->visit($this->root); } } public function genCSS( $output ){ if( $this->css ){ $output->add( '@import ', $this->currentFileInfo, $this->index ); $this->path->genCSS( $output ); if( $this->features ){ $output->add( ' ' ); $this->features->genCSS( $output ); } $output->add( ';' ); } } public function toCSS(){ $features = $this->features ? ' ' . $this->features->toCSS() : ''; if ($this->css) { return "@import " . $this->path->toCSS() . $features . ";\n"; } else { return ""; } } public function getPath(){ if ($this->path instanceof Less_Tree_Quoted) { $path = $this->path->value; $path = ( isset($this->css) || preg_match('/(\.[a-z]*$)|([\?;].*)$/',$path)) ? $path : $path . '.less'; } else if ($this->path instanceof Less_Tree_URL) { $path = $this->path->value->value; }else{ return null; } return preg_replace('/[\?#][^\?]*$/','',$path); } public function compileForImport( $env ){ return new Less_Tree_Import( $this->path->compile($env), $this->features, $this->options, $this->index, $this->currentFileInfo); } public function compilePath($env) { $path = $this->path->compile($env); $rootpath = ''; if( $this->currentFileInfo && $this->currentFileInfo['rootpath'] ){ $rootpath = $this->currentFileInfo['rootpath']; } if( !($path instanceof Less_Tree_URL) ){ if( $rootpath ){ $pathValue = $path->value; if( $pathValue && Less_Environment::isPathRelative($pathValue) ){ $path->value = $this->currentFileInfo['uri_root'].$pathValue; } } $path->value = Less_Environment::normalizePath($path->value); } return $path; } public function compile( $env ){ $evald = $this->compileForImport($env); $path_and_uri = null; if( is_callable(Less_Parser::$options['import_callback']) ){ $path_and_uri = call_user_func(Less_Parser::$options['import_callback'],$evald); } if( !$path_and_uri ){ $path_and_uri = $evald->PathAndUri(); } if( $path_and_uri ){ list($full_path, $uri) = $path_and_uri; }else{ $full_path = $uri = $evald->getPath(); } if( $evald->skip( $full_path, $env) ){ return array(); } if( $this->options['inline'] ){ Less_Parser::AddParsedFile($full_path); $contents = new Less_Tree_Anonymous( file_get_contents($full_path), 0, array(), true ); if( $this->features ){ return new Less_Tree_Media( array($contents), $this->features->value ); } return array( $contents ); } if( isset($this->options['optional']) && $this->options['optional'] && !file_exists($full_path) && (!$evald->css || !empty($this->currentFileInfo))) { return array(); } if( $evald->css ){ $features = ( $evald->features ? $evald->features->compile($env) : null ); return new Less_Tree_Import( $this->compilePath( $env), $features, $this->options, $this->index); } return $this->ParseImport( $full_path, $uri, $env ); } public function PathAndUri(){ $evald_path = $this->getPath(); if( $evald_path ){ $import_dirs = array(); if( Less_Environment::isPathRelative($evald_path) ){ $import_dirs[ $this->currentFileInfo['currentDirectory'] ] = $this->currentFileInfo['uri_root']; }else{ $import_dirs[ $this->currentFileInfo['entryPath'] ] = $this->currentFileInfo['entryUri']; $import_dirs[ $_SERVER['DOCUMENT_ROOT'] ] = ''; } $import_dirs = array_merge( $import_dirs, Less_Parser::$options['import_dirs'] ); foreach( $import_dirs as $rootpath => $rooturi){ if( is_callable($rooturi) ){ list($path, $uri) = call_user_func($rooturi, $evald_path); if( is_string($path) ){ $full_path = $path; return array( $full_path, $uri ); } }elseif( !empty($rootpath) ){ if( $rooturi ){ if( strpos($evald_path,$rooturi) === 0 ){ $evald_path = substr( $evald_path, strlen($rooturi) ); } } $path = rtrim($rootpath,'/\\').'/'.ltrim($evald_path,'/\\'); if( file_exists($path) ){ $full_path = Less_Environment::normalizePath($path); $uri = Less_Environment::normalizePath(dirname($rooturi.$evald_path)); return array( $full_path, $uri ); } elseif( file_exists($path.'.less') ){ $full_path = Less_Environment::normalizePath($path.'.less'); $uri = Less_Environment::normalizePath(dirname($rooturi.$evald_path.'.less')); return array( $full_path, $uri ); } } } } } public function ParseImport( $full_path, $uri, $env ){ $import_env = clone $env; if( (isset($this->options['reference']) && $this->options['reference']) || isset($this->currentFileInfo['reference']) ){ $import_env->currentFileInfo['reference'] = true; } if( (isset($this->options['multiple']) && $this->options['multiple']) ){ $import_env->importMultiple = true; } $parser = new Less_Parser($import_env); $root = $parser->parseFile($full_path, $uri, true); $ruleset = new Less_Tree_Ruleset(array(), $root->rules ); $ruleset->evalImports($import_env); return $this->features ? new Less_Tree_Media($ruleset->rules, $this->features->value) : $ruleset->rules; } private function Skip($path, $env){ $path = Less_Parser::winPath(realpath($path)); if( $path && Less_Parser::FileParsed($path) ){ if( isset($this->currentFileInfo['reference']) ){ return true; } return !isset($this->options['multiple']) && !$env->importMultiple; } } } class Less_Tree_Javascript extends Less_Tree{ public $type = 'Javascript'; public $escaped; public $expression; public $index; public function __construct($string, $index, $escaped){ $this->escaped = $escaped; $this->expression = $string; $this->index = $index; } public function compile(){ return new Less_Tree_Anonymous('/* Sorry, can not do JavaScript evaluation in PHP... :( */'); } } class Less_Tree_Keyword extends Less_Tree{ public $value; public $type = 'Keyword'; public function __construct($value){ $this->value = $value; } public function compile(){ return $this; } public function genCSS( $output ){ if( $this->value === '%') { throw new Less_Exception_Compiler("Invalid % without number"); } $output->add( $this->value ); } public function compare($other) { if ($other instanceof Less_Tree_Keyword) { return $other->value === $this->value ? 0 : 1; } else { return -1; } } } class Less_Tree_Media extends Less_Tree{ public $features; public $rules; public $index; public $currentFileInfo; public $isReferenced; public $type = 'Media'; public function __construct($value = array(), $features = array(), $index = null, $currentFileInfo = null ){ $this->index = $index; $this->currentFileInfo = $currentFileInfo; $selectors = $this->emptySelectors(); $this->features = new Less_Tree_Value($features); $this->rules = array(new Less_Tree_Ruleset($selectors, $value)); $this->rules[0]->allowImports = true; } public function accept( $visitor ){ $this->features = $visitor->visitObj($this->features); $this->rules = $visitor->visitArray($this->rules); } public function genCSS( $output ){ $output->add( '@media ', $this->currentFileInfo, $this->index ); $this->features->genCSS( $output ); Less_Tree::outputRuleset( $output, $this->rules); } public function compile($env) { $media = new Less_Tree_Media(array(), array(), $this->index, $this->currentFileInfo ); $strictMathBypass = false; if( Less_Parser::$options['strictMath'] === false) { $strictMathBypass = true; Less_Parser::$options['strictMath'] = true; } $media->features = $this->features->compile($env); if( $strictMathBypass ){ Less_Parser::$options['strictMath'] = false; } $env->mediaPath[] = $media; $env->mediaBlocks[] = $media; array_unshift($env->frames, $this->rules[0]); $media->rules = array($this->rules[0]->compile($env)); array_shift($env->frames); array_pop($env->mediaPath); return !$env->mediaPath ? $media->compileTop($env) : $media->compileNested($env); } public function variable($name) { return $this->rules[0]->variable($name); } public function find($selector) { return $this->rules[0]->find($selector, $this); } public function emptySelectors(){ $el = new Less_Tree_Element('','&', $this->index, $this->currentFileInfo ); $sels = array( new Less_Tree_Selector(array($el), array(), null, $this->index, $this->currentFileInfo) ); $sels[0]->mediaEmpty = true; return $sels; } public function markReferenced(){ $this->rules[0]->markReferenced(); $this->isReferenced = true; Less_Tree::ReferencedArray($this->rules[0]->rules); } public function compileTop($env) { $result = $this; if (count($env->mediaBlocks) > 1) { $selectors = $this->emptySelectors(); $result = new Less_Tree_Ruleset($selectors, $env->mediaBlocks); $result->multiMedia = true; } $env->mediaBlocks = array(); $env->mediaPath = array(); return $result; } public function compileNested($env) { $path = array_merge($env->mediaPath, array($this)); foreach ($path as $key => $p) { $value = $p->features instanceof Less_Tree_Value ? $p->features->value : $p->features; $path[$key] = is_array($value) ? $value : array($value); } $permuted = $this->permute($path); $expressions = array(); foreach($permuted as $path){ for( $i=0, $len=count($path); $i < $len; $i++){ $path[$i] = Less_Parser::is_method($path[$i], 'toCSS') ? $path[$i] : new Less_Tree_Anonymous($path[$i]); } for( $i = count($path) - 1; $i > 0; $i-- ){ array_splice($path, $i, 0, array(new Less_Tree_Anonymous('and'))); } $expressions[] = new Less_Tree_Expression($path); } $this->features = new Less_Tree_Value($expressions); return new Less_Tree_Ruleset(array(), array()); } public function permute($arr) { if (!$arr) return array(); if (count($arr) == 1) return $arr[0]; $result = array(); $rest = $this->permute(array_slice($arr, 1)); foreach ($rest as $r) { foreach ($arr[0] as $a) { $result[] = array_merge( is_array($a) ? $a : array($a), is_array($r) ? $r : array($r) ); } } return $result; } public function bubbleSelectors($selectors) { if( !$selectors) return; $this->rules = array(new Less_Tree_Ruleset( $selectors, array($this->rules[0]))); } } class Less_Tree_NameValue extends Less_Tree{ public $name; public $value; public $index; public $currentFileInfo; public $type = 'NameValue'; public $important = ''; public function __construct($name, $value = null, $index = null, $currentFileInfo = null ){ $this->name = $name; $this->value = $value; $this->index = $index; $this->currentFileInfo = $currentFileInfo; } public function genCSS( $output ){ $output->add( $this->name . Less_Environment::$_outputMap[': '] . $this->value . $this->important . (((Less_Environment::$lastRule && Less_Parser::$options['compress'])) ? "" : ";") , $this->currentFileInfo, $this->index); } public function compile ($env){ return $this; } public function makeImportant(){ $new = new Less_Tree_NameValue($this->name, $this->value, $this->index, $this->currentFileInfo); $new->important = ' !important'; return $new; } } class Less_Tree_Negative extends Less_Tree{ public $value; public $type = 'Negative'; public function __construct($node){ $this->value = $node; } public function genCSS( $output ){ $output->add( '-' ); $this->value->genCSS( $output ); } public function compile($env) { if( Less_Environment::isMathOn() ){ $ret = new Less_Tree_Operation('*', array( new Less_Tree_Dimension(-1), $this->value ) ); return $ret->compile($env); } return new Less_Tree_Negative( $this->value->compile($env) ); } } class Less_Tree_Operation extends Less_Tree{ public $op; public $operands; public $isSpaced; public $type = 'Operation'; public function __construct($op, $operands, $isSpaced = false){ $this->op = trim($op); $this->operands = $operands; $this->isSpaced = $isSpaced; } public function accept($visitor) { $this->operands = $visitor->visitArray($this->operands); } public function compile($env){ $a = $this->operands[0]->compile($env); $b = $this->operands[1]->compile($env); if( Less_Environment::isMathOn() ){ if( $a instanceof Less_Tree_Dimension && $b instanceof Less_Tree_Color ){ $a = $a->toColor(); }elseif( $b instanceof Less_Tree_Dimension && $a instanceof Less_Tree_Color ){ $b = $b->toColor(); } if( !method_exists($a,'operate') ){ throw new Less_Exception_Compiler("Operation on an invalid type"); } return $a->operate( $this->op, $b); } return new Less_Tree_Operation($this->op, array($a, $b), $this->isSpaced ); } public function genCSS( $output ){ $this->operands[0]->genCSS( $output ); if( $this->isSpaced ){ $output->add( " " ); } $output->add( $this->op ); if( $this->isSpaced ){ $output->add( ' ' ); } $this->operands[1]->genCSS( $output ); } } class Less_Tree_Paren extends Less_Tree{ public $value; public $type = 'Paren'; public function __construct($value) { $this->value = $value; } public function accept($visitor){ $this->value = $visitor->visitObj($this->value); } public function genCSS( $output ){ $output->add( '(' ); $this->value->genCSS( $output ); $output->add( ')' ); } public function compile($env) { return new Less_Tree_Paren($this->value->compile($env)); } } class Less_Tree_Quoted extends Less_Tree{ public $escaped; public $value; public $quote; public $index; public $currentFileInfo; public $type = 'Quoted'; public function __construct($str, $content = '', $escaped = false, $index = false, $currentFileInfo = null ){ $this->escaped = $escaped; $this->value = $content; if( $str ){ $this->quote = $str[0]; } $this->index = $index; $this->currentFileInfo = $currentFileInfo; } public function genCSS( $output ){ if( !$this->escaped ){ $output->add( $this->quote, $this->currentFileInfo, $this->index ); } $output->add( $this->value ); if( !$this->escaped ){ $output->add( $this->quote ); } } public function compile($env){ $value = $this->value; if( preg_match_all('/`([^`]+)`/', $this->value, $matches) ){ foreach($matches as $i => $match){ $js = new Less_Tree_JavaScript($matches[1], $this->index, true); $js = $js->compile()->value; $value = str_replace($matches[0][$i], $js, $value); } } if( preg_match_all('/@\{([\w-]+)\}/',$value,$matches) ){ foreach($matches[1] as $i => $match){ $v = new Less_Tree_Variable('@' . $match, $this->index, $this->currentFileInfo ); $v = $v->compile($env); $v = ($v instanceof Less_Tree_Quoted) ? $v->value : $v->toCSS(); $value = str_replace($matches[0][$i], $v, $value); } } return new Less_Tree_Quoted($this->quote . $value . $this->quote, $value, $this->escaped, $this->index, $this->currentFileInfo); } public function compare($x) { if( !Less_Parser::is_method($x, 'toCSS') ){ return -1; } $left = $this->toCSS(); $right = $x->toCSS(); if ($left === $right) { return 0; } return $left < $right ? -1 : 1; } } class Less_Tree_Rule extends Less_Tree{ public $name; public $value; public $important; public $merge; public $index; public $inline; public $variable; public $currentFileInfo; public $type = 'Rule'; public function __construct($name, $value = null, $important = null, $merge = null, $index = null, $currentFileInfo = null, $inline = false){ $this->name = $name; $this->value = ($value instanceof Less_Tree_Value || $value instanceof Less_Tree_Ruleset) ? $value : new Less_Tree_Value(array($value)); $this->important = $important ? ' ' . trim($important) : ''; $this->merge = $merge; $this->index = $index; $this->currentFileInfo = $currentFileInfo; $this->inline = $inline; $this->variable = ( is_string($name) && $name[0] === '@'); } public function accept($visitor) { $this->value = $visitor->visitObj( $this->value ); } public function genCSS( $output ){ $output->add( $this->name . Less_Environment::$_outputMap[': '], $this->currentFileInfo, $this->index); try{ $this->value->genCSS( $output); }catch( Less_Exception_Parser $e ){ $e->index = $this->index; $e->currentFile = $this->currentFileInfo; throw $e; } $output->add( $this->important . (($this->inline || (Less_Environment::$lastRule && Less_Parser::$options['compress'])) ? "" : ";"), $this->currentFileInfo, $this->index); } public function compile ($env){ $name = $this->name; if( is_array($name) ){ if( count($name) === 1 && $name[0] instanceof Less_Tree_Keyword ){ $name = $name[0]->value; }else{ $name = $this->CompileName($env,$name); } } $strictMathBypass = Less_Parser::$options['strictMath']; if( $name === "font" && !Less_Parser::$options['strictMath'] ){ Less_Parser::$options['strictMath'] = true; } try { $evaldValue = $this->value->compile($env); if( !$this->variable && $evaldValue->type === "DetachedRuleset") { throw new Less_Exception_Compiler("Rulesets cannot be evaluated on a property.", null, $this->index, $this->currentFileInfo); } if( Less_Environment::$mixin_stack ){ $return = new Less_Tree_Rule($name, $evaldValue, $this->important, $this->merge, $this->index, $this->currentFileInfo, $this->inline); }else{ $this->name = $name; $this->value = $evaldValue; $return = $this; } }catch( Less_Exception_Parser $e ){ if( !is_numeric($e->index) ){ $e->index = $this->index; $e->currentFile = $this->currentFileInfo; } throw $e; } Less_Parser::$options['strictMath'] = $strictMathBypass; return $return; } public function CompileName( $env, $name ){ $output = new Less_Output(); foreach($name as $n){ $n->compile($env)->genCSS($output); } return $output->toString(); } public function makeImportant(){ return new Less_Tree_Rule($this->name, $this->value, '!important', $this->merge, $this->index, $this->currentFileInfo, $this->inline); } } class Less_Tree_Ruleset extends Less_Tree{ protected $lookups; public $_variables; public $_rulesets; public $strictImports; public $selectors; public $rules; public $root; public $allowImports; public $paths; public $firstRoot; public $type = 'Ruleset'; public $multiMedia; public $allExtends; public $ruleset_id; public $originalRuleset; public $first_oelements; public function SetRulesetIndex(){ $this->ruleset_id = Less_Parser::$next_id++; $this->originalRuleset = $this->ruleset_id; if( $this->selectors ){ foreach($this->selectors as $sel){ if( $sel->_oelements ){ $this->first_oelements[$sel->_oelements[0]] = true; } } } } public function __construct($selectors, $rules, $strictImports = null){ $this->selectors = $selectors; $this->rules = $rules; $this->lookups = array(); $this->strictImports = $strictImports; $this->SetRulesetIndex(); } public function accept( $visitor ){ if( $this->paths ){ $paths_len = count($this->paths); for($i = 0,$paths_len; $i < $paths_len; $i++ ){ $this->paths[$i] = $visitor->visitArray($this->paths[$i]); } }elseif( $this->selectors ){ $this->selectors = $visitor->visitArray($this->selectors); } if( $this->rules ){ $this->rules = $visitor->visitArray($this->rules); } } public function compile($env){ $ruleset = $this->PrepareRuleset($env); $rsRuleCnt = count($ruleset->rules); for( $i = 0; $i < $rsRuleCnt; $i++ ){ if( $ruleset->rules[$i] instanceof Less_Tree_Mixin_Definition || $ruleset->rules[$i] instanceof Less_Tree_DetachedRuleset ){ $ruleset->rules[$i] = $ruleset->rules[$i]->compile($env); } } $mediaBlockCount = 0; if( $env instanceof Less_Environment ){ $mediaBlockCount = count($env->mediaBlocks); } $this->EvalMixinCalls( $ruleset, $env, $rsRuleCnt ); for( $i=0; $i<$rsRuleCnt; $i++ ){ if(! ($ruleset->rules[$i] instanceof Less_Tree_Mixin_Definition || $ruleset->rules[$i] instanceof Less_Tree_DetachedRuleset) ){ $ruleset->rules[$i] = $ruleset->rules[$i]->compile($env); } } for( $i=0; $i<$rsRuleCnt; $i++ ){ $rule = $ruleset->rules[$i]; if( $rule instanceof Less_Tree_Ruleset && $rule->selectors && count($rule->selectors) === 1 ){ if( $rule->selectors[0]->isJustParentSelector() ){ array_splice($ruleset->rules,$i--,1); $rsRuleCnt--; for($j = 0; $j < count($rule->rules); $j++ ){ $subRule = $rule->rules[$j]; if( !($subRule instanceof Less_Tree_Rule) || !$subRule->variable ){ array_splice($ruleset->rules, ++$i, 0, array($subRule)); $rsRuleCnt++; } } } } } $env->shiftFrame(); if ($mediaBlockCount) { $len = count($env->mediaBlocks); for($i = $mediaBlockCount; $i < $len; $i++ ){ $env->mediaBlocks[$i]->bubbleSelectors($ruleset->selectors); } } return $ruleset; } private function EvalMixinCalls( $ruleset, $env, &$rsRuleCnt ){ for($i=0; $i < $rsRuleCnt; $i++){ $rule = $ruleset->rules[$i]; if( $rule instanceof Less_Tree_Mixin_Call ){ $rule = $rule->compile($env); $temp = array(); foreach($rule as $r){ if( ($r instanceof Less_Tree_Rule) && $r->variable ){ if( !$ruleset->variable($r->name) ){ $temp[] = $r; } }else{ $temp[] = $r; } } $temp_count = count($temp)-1; array_splice($ruleset->rules, $i, 1, $temp); $rsRuleCnt += $temp_count; $i += $temp_count; $ruleset->resetCache(); }elseif( $rule instanceof Less_Tree_RulesetCall ){ $rule = $rule->compile($env); $rules = array(); foreach($rule->rules as $r){ if( ($r instanceof Less_Tree_Rule) && $r->variable ){ continue; } $rules[] = $r; } array_splice($ruleset->rules, $i, 1, $rules); $temp_count = count($rules); $rsRuleCnt += $temp_count - 1; $i += $temp_count-1; $ruleset->resetCache(); } } } private function PrepareRuleset($env){ $hasOnePassingSelector = false; $selectors = array(); if( $this->selectors ){ Less_Tree_DefaultFunc::error("it is currently only allowed in parametric mixin guards,"); foreach($this->selectors as $s){ $selector = $s->compile($env); $selectors[] = $selector; if( $selector->evaldCondition ){ $hasOnePassingSelector = true; } } Less_Tree_DefaultFunc::reset(); } else { $hasOnePassingSelector = true; } if( $this->rules && $hasOnePassingSelector ){ $rules = $this->rules; }else{ $rules = array(); } $ruleset = new Less_Tree_Ruleset($selectors, $rules, $this->strictImports); $ruleset->originalRuleset = $this->ruleset_id; $ruleset->root = $this->root; $ruleset->firstRoot = $this->firstRoot; $ruleset->allowImports = $this->allowImports; $env->unshiftFrame($ruleset); if( $ruleset->root || $ruleset->allowImports || !$ruleset->strictImports ){ $ruleset->evalImports($env); } return $ruleset; } function evalImports($env) { $rules_len = count($this->rules); for($i=0; $i < $rules_len; $i++){ $rule = $this->rules[$i]; if( $rule instanceof Less_Tree_Import ){ $rules = $rule->compile($env); if( is_array($rules) ){ array_splice($this->rules, $i, 1, $rules); $temp_count = count($rules)-1; $i += $temp_count; $rules_len += $temp_count; }else{ array_splice($this->rules, $i, 1, array($rules)); } $this->resetCache(); } } } function makeImportant(){ $important_rules = array(); foreach($this->rules as $rule){ if( $rule instanceof Less_Tree_Rule || $rule instanceof Less_Tree_Ruleset || $rule instanceof Less_Tree_NameValue ){ $important_rules[] = $rule->makeImportant(); }else{ $important_rules[] = $rule; } } return new Less_Tree_Ruleset($this->selectors, $important_rules, $this->strictImports ); } public function matchArgs($args){ return !$args; } public function matchCondition( $args, $env ){ $lastSelector = end($this->selectors); if( !$lastSelector->evaldCondition ){ return false; } if( $lastSelector->condition && !$lastSelector->condition->compile( $env->copyEvalEnv( $env->frames ) ) ){ return false; } return true; } function resetCache(){ $this->_rulesets = null; $this->_variables = null; $this->lookups = array(); } public function variables(){ $this->_variables = array(); foreach( $this->rules as $r){ if ($r instanceof Less_Tree_Rule && $r->variable === true) { $this->_variables[$r->name] = $r; } } } public function variable($name){ if( is_null($this->_variables) ){ $this->variables(); } return isset($this->_variables[$name]) ? $this->_variables[$name] : null; } public function find( $selector, $self = null ){ $key = implode(' ',$selector->_oelements); if( !isset($this->lookups[$key]) ){ if( !$self ){ $self = $this->ruleset_id; } $this->lookups[$key] = array(); $first_oelement = $selector->_oelements[0]; foreach($this->rules as $rule){ if( $rule instanceof Less_Tree_Ruleset && $rule->ruleset_id != $self ){ if( isset($rule->first_oelements[$first_oelement]) ){ foreach( $rule->selectors as $ruleSelector ){ $match = $selector->match($ruleSelector); if( $match ){ if( $selector->elements_len > $match ){ $this->lookups[$key] = array_merge($this->lookups[$key], $rule->find( new Less_Tree_Selector(array_slice($selector->elements, $match)), $self)); } else { $this->lookups[$key][] = $rule; } break; } } } } } } return $this->lookups[$key]; } public function genCSS( $output ){ if( !$this->root ){ Less_Environment::$tabLevel++; } $tabRuleStr = $tabSetStr = ''; if( !Less_Parser::$options['compress'] ){ if( Less_Environment::$tabLevel ){ $tabRuleStr = "\n".str_repeat( Less_Parser::$options['indentation'] , Less_Environment::$tabLevel ); $tabSetStr = "\n".str_repeat( Less_Parser::$options['indentation'] , Less_Environment::$tabLevel-1 ); }else{ $tabSetStr = $tabRuleStr = "\n"; } } $ruleNodes = array(); $rulesetNodes = array(); foreach($this->rules as $rule){ $class = get_class($rule); if( ($class === 'Less_Tree_Media') || ($class === 'Less_Tree_Directive') || ($this->root && $class === 'Less_Tree_Comment') || ($class === 'Less_Tree_Ruleset' && $rule->rules) ){ $rulesetNodes[] = $rule; }else{ $ruleNodes[] = $rule; } } if( !$this->root ){ $paths_len = count($this->paths); for( $i = 0; $i < $paths_len; $i++ ){ $path = $this->paths[$i]; $firstSelector = true; foreach($path as $p){ $p->genCSS( $output, $firstSelector ); $firstSelector = false; } if( $i + 1 < $paths_len ){ $output->add( ',' . $tabSetStr ); } } $output->add( (Less_Parser::$options['compress'] ? '{' : " {") . $tabRuleStr ); } $ruleNodes_len = count($ruleNodes); $rulesetNodes_len = count($rulesetNodes); for( $i = 0; $i < $ruleNodes_len; $i++ ){ $rule = $ruleNodes[$i]; if( $i + 1 === $ruleNodes_len && (!$this->root || $rulesetNodes_len === 0 || $this->firstRoot ) ){ Less_Environment::$lastRule = true; } $rule->genCSS( $output ); if( !Less_Environment::$lastRule ){ $output->add( $tabRuleStr ); }else{ Less_Environment::$lastRule = false; } } if( !$this->root ){ $output->add( $tabSetStr . '}' ); Less_Environment::$tabLevel--; } $firstRuleset = true; $space = ($this->root ? $tabRuleStr : $tabSetStr); for( $i = 0; $i < $rulesetNodes_len; $i++ ){ if( $ruleNodes_len && $firstRuleset ){ $output->add( $space ); }elseif( !$firstRuleset ){ $output->add( $space ); } $firstRuleset = false; $rulesetNodes[$i]->genCSS( $output); } if( !Less_Parser::$options['compress'] && $this->firstRoot ){ $output->add( "\n" ); } } function markReferenced(){ if( !$this->selectors ){ return; } foreach($this->selectors as $selector){ $selector->markReferenced(); } } public function joinSelectors( $context, $selectors ){ $paths = array(); if( is_array($selectors) ){ foreach($selectors as $selector) { $this->joinSelector( $paths, $context, $selector); } } return $paths; } public function joinSelector( &$paths, $context, $selector){ $hasParentSelector = false; foreach($selector->elements as $el) { if( $el->value === '&') { $hasParentSelector = true; } } if( !$hasParentSelector ){ if( $context ){ foreach($context as $context_el){ $paths[] = array_merge($context_el, array($selector) ); } }else { $paths[] = array($selector); } return; } $currentElements = array(); $newSelectors = array(array()); foreach( $selector->elements as $el){ if( $el->value !== '&' ){ $currentElements[] = $el; } else { $selectorsMultiplied = array(); if( $currentElements ){ $this->mergeElementsOnToSelectors( $currentElements, $newSelectors); } foreach($newSelectors as $sel){ if( !$context ){ if( $sel ){ $sel[0]->elements = array_slice($sel[0]->elements,0); $sel[0]->elements[] = new Less_Tree_Element($el->combinator, '', $el->index, $el->currentFileInfo ); } $selectorsMultiplied[] = $sel; }else { foreach($context as $parentSel){ $newSelectorPath = array(); $afterParentJoin = array(); $newJoinedSelectorEmpty = true; if( $sel ){ $newSelectorPath = $sel; $lastSelector = array_pop($newSelectorPath); $newJoinedSelector = $selector->createDerived( array_slice($lastSelector->elements,0) ); $newJoinedSelectorEmpty = false; } else { $newJoinedSelector = $selector->createDerived(array()); } if ( count($parentSel) > 1) { $afterParentJoin = array_merge($afterParentJoin, array_slice($parentSel,1) ); } if ( $parentSel ){ $newJoinedSelectorEmpty = false; $newJoinedSelector->elements[] = new Less_Tree_Element( $el->combinator, $parentSel[0]->elements[0]->value, $el->index, $el->currentFileInfo); $newJoinedSelector->elements = array_merge( $newJoinedSelector->elements, array_slice($parentSel[0]->elements, 1) ); } if (!$newJoinedSelectorEmpty) { $newSelectorPath[] = $newJoinedSelector; } $newSelectorPath = array_merge($newSelectorPath, $afterParentJoin); $selectorsMultiplied[] = $newSelectorPath; } } } $newSelectors = $selectorsMultiplied; $currentElements = array(); } } if( $currentElements ){ $this->mergeElementsOnToSelectors($currentElements, $newSelectors); } foreach( $newSelectors as $new_sel){ if( $new_sel ){ $paths[] = $new_sel; } } } function mergeElementsOnToSelectors( $elements, &$selectors){ if( !$selectors ){ $selectors[] = array( new Less_Tree_Selector($elements) ); return; } foreach( $selectors as &$sel){ if( $sel ){ $last = count($sel)-1; $sel[$last] = $sel[$last]->createDerived( array_merge($sel[$last]->elements, $elements) ); }else{ $sel[] = new Less_Tree_Selector( $elements ); } } } } class Less_Tree_RulesetCall extends Less_Tree{ public $variable; public $type = "RulesetCall"; public function __construct($variable){ $this->variable = $variable; } public function accept($visitor) {} public function compile( $env ){ $variable = new Less_Tree_Variable($this->variable); $detachedRuleset = $variable->compile($env); return $detachedRuleset->callEval($env); } } class Less_Tree_Selector extends Less_Tree{ public $elements; public $condition; public $extendList = array(); public $_css; public $index; public $evaldCondition = false; public $type = 'Selector'; public $currentFileInfo = array(); public $isReferenced; public $mediaEmpty; public $elements_len = 0; public $_oelements; public $_oelements_len; public $cacheable = true; public function __construct( $elements, $extendList = array() , $condition = null, $index=null, $currentFileInfo=null, $isReferenced=null ){ $this->elements = $elements; $this->elements_len = count($elements); $this->extendList = $extendList; $this->condition = $condition; if( $currentFileInfo ){ $this->currentFileInfo = $currentFileInfo; } $this->isReferenced = $isReferenced; if( !$condition ){ $this->evaldCondition = true; } $this->CacheElements(); } public function accept($visitor) { $this->elements = $visitor->visitArray($this->elements); $this->extendList = $visitor->visitArray($this->extendList); if( $this->condition ){ $this->condition = $visitor->visitObj($this->condition); } if( $visitor instanceof Less_Visitor_extendFinder ){ $this->CacheElements(); } } public function createDerived( $elements, $extendList = null, $evaldCondition = null ){ $newSelector = new Less_Tree_Selector( $elements, ($extendList ? $extendList : $this->extendList), null, $this->index, $this->currentFileInfo, $this->isReferenced); $newSelector->evaldCondition = $evaldCondition ? $evaldCondition : $this->evaldCondition; return $newSelector; } public function match( $other ){ if( !$other->_oelements || ($this->elements_len < $other->_oelements_len) ){ return 0; } for( $i = 0; $i < $other->_oelements_len; $i++ ){ if( $this->elements[$i]->value !== $other->_oelements[$i]) { return 0; } } return $other->_oelements_len; } public function CacheElements(){ $this->_oelements = array(); $css = ''; foreach($this->elements as $v){ $css .= $v->combinator; if( !$v->value_is_object ){ $css .= $v->value; continue; } if( !property_exists($v->value,'value') || !is_string($v->value->value) ){ $this->cacheable = false; return; } $css .= $v->value->value; } $this->_oelements_len = preg_match_all('/[,&#\.\w-](?:[\w-]|(?:\\\\.))*/', $css, $matches); if( $this->_oelements_len ){ $this->_oelements = $matches[0]; if( $this->_oelements[0] === '&' ){ array_shift($this->_oelements); $this->_oelements_len--; } } } public function isJustParentSelector(){ return !$this->mediaEmpty && count($this->elements) === 1 && $this->elements[0]->value === '&' && ($this->elements[0]->combinator === ' ' || $this->elements[0]->combinator === ''); } public function compile($env) { $elements = array(); foreach($this->elements as $el){ $elements[] = $el->compile($env); } $extendList = array(); foreach($this->extendList as $el){ $extendList[] = $el->compile($el); } $evaldCondition = false; if( $this->condition ){ $evaldCondition = $this->condition->compile($env); } return $this->createDerived( $elements, $extendList, $evaldCondition ); } public function genCSS( $output, $firstSelector = true ){ if( !$firstSelector && $this->elements[0]->combinator === "" ){ $output->add(' ', $this->currentFileInfo, $this->index); } foreach($this->elements as $element){ $element->genCSS( $output ); } } public function markReferenced(){ $this->isReferenced = true; } public function getIsReferenced(){ return !isset($this->currentFileInfo['reference']) || !$this->currentFileInfo['reference'] || $this->isReferenced; } public function getIsOutput(){ return $this->evaldCondition; } } class Less_Tree_UnicodeDescriptor extends Less_Tree{ public $value; public $type = 'UnicodeDescriptor'; public function __construct($value){ $this->value = $value; } public function genCSS( $output ){ $output->add( $this->value ); } public function compile(){ return $this; } } class Less_Tree_Unit extends Less_Tree{ var $numerator = array(); var $denominator = array(); public $backupUnit; public $type = 'Unit'; public function __construct($numerator = array(), $denominator = array(), $backupUnit = null ){ $this->numerator = $numerator; $this->denominator = $denominator; $this->backupUnit = $backupUnit; } public function __clone(){ } public function genCSS( $output ){ if( $this->numerator ){ $output->add( $this->numerator[0] ); }elseif( $this->denominator ){ $output->add( $this->denominator[0] ); }elseif( !Less_Parser::$options['strictUnits'] && $this->backupUnit ){ $output->add( $this->backupUnit ); return ; } } public function toString(){ $returnStr = implode('*',$this->numerator); foreach($this->denominator as $d){ $returnStr .= '/'.$d; } return $returnStr; } public function __toString(){ return $this->toString(); } public function compare($other) { return $this->is( $other->toString() ) ? 0 : -1; } public function is($unitString){ return $this->toString() === $unitString; } public function isLength(){ $css = $this->toCSS(); return !!preg_match('/px|em|%|in|cm|mm|pc|pt|ex/',$css); } public function isAngle() { return isset( Less_Tree_UnitConversions::$angle[$this->toCSS()] ); } public function isEmpty(){ return !$this->numerator && !$this->denominator; } public function isSingular() { return count($this->numerator) <= 1 && !$this->denominator; } public function usedUnits(){ $result = array(); foreach(Less_Tree_UnitConversions::$groups as $groupName){ $group = Less_Tree_UnitConversions::${$groupName}; foreach($this->numerator as $atomicUnit){ if( isset($group[$atomicUnit]) && !isset($result[$groupName]) ){ $result[$groupName] = $atomicUnit; } } foreach($this->denominator as $atomicUnit){ if( isset($group[$atomicUnit]) && !isset($result[$groupName]) ){ $result[$groupName] = $atomicUnit; } } } return $result; } public function cancel(){ $counter = array(); $backup = null; foreach($this->numerator as $atomicUnit){ if( !$backup ){ $backup = $atomicUnit; } $counter[$atomicUnit] = ( isset($counter[$atomicUnit]) ? $counter[$atomicUnit] : 0) + 1; } foreach($this->denominator as $atomicUnit){ if( !$backup ){ $backup = $atomicUnit; } $counter[$atomicUnit] = ( isset($counter[$atomicUnit]) ? $counter[$atomicUnit] : 0) - 1; } $this->numerator = array(); $this->denominator = array(); foreach($counter as $atomicUnit => $count){ if( $count > 0 ){ for( $i = 0; $i < $count; $i++ ){ $this->numerator[] = $atomicUnit; } }elseif( $count < 0 ){ for( $i = 0; $i < -$count; $i++ ){ $this->denominator[] = $atomicUnit; } } } if( !$this->numerator && !$this->denominator && $backup ){ $this->backupUnit = $backup; } sort($this->numerator); sort($this->denominator); } } class Less_Tree_UnitConversions{ public static $groups = array('length','duration','angle'); public static $length = array( 'm'=> 1, 'cm'=> 0.01, 'mm'=> 0.001, 'in'=> 0.0254, 'px'=> 0.000264583, 'pt'=> 0.000352778, 'pc'=> 0.004233333, ); public static $duration = array( 's'=> 1, 'ms'=> 0.001 ); public static $angle = array( 'rad' => 0.1591549430919, 'deg' => 0.002777778, 'grad'=> 0.0025, 'turn'=> 1 ); } class Less_Tree_Url extends Less_Tree{ public $attrs; public $value; public $currentFileInfo; public $isEvald; public $type = 'Url'; public function __construct($value, $currentFileInfo = null, $isEvald = null){ $this->value = $value; $this->currentFileInfo = $currentFileInfo; $this->isEvald = $isEvald; } public function accept( $visitor ){ $this->value = $visitor->visitObj($this->value); } public function genCSS( $output ){ $output->add( 'url(' ); $this->value->genCSS( $output ); $output->add( ')' ); } public function compile($ctx){ $val = $this->value->compile($ctx); if( !$this->isEvald ){ if( Less_Parser::$options['relativeUrls'] && $this->currentFileInfo && is_string($val->value) && Less_Environment::isPathRelative($val->value) ){ $rootpath = $this->currentFileInfo['uri_root']; if ( !$val->quote ){ $rootpath = preg_replace('/[\(\)\'"\s]/', '\\$1', $rootpath ); } $val->value = $rootpath . $val->value; } $val->value = Less_Environment::normalizePath( $val->value); } if( Less_Parser::$options['urlArgs'] ){ if( !preg_match('/^\s*data:/',$val->value) ){ $delimiter = strpos($val->value,'?') === false ? '?' : '&'; $urlArgs = $delimiter . Less_Parser::$options['urlArgs']; $hash_pos = strpos($val->value,'#'); if( $hash_pos !== false ){ $val->value = substr_replace($val->value,$urlArgs, $hash_pos, 0); } else { $val->value .= $urlArgs; } } } return new Less_Tree_URL($val, $this->currentFileInfo, true); } } class Less_Tree_Value extends Less_Tree{ public $type = 'Value'; public $value; public function __construct($value){ $this->value = $value; } public function accept($visitor) { $this->value = $visitor->visitArray($this->value); } public function compile($env){ $ret = array(); $i = 0; foreach($this->value as $i => $v){ $ret[] = $v->compile($env); } if( $i > 0 ){ return new Less_Tree_Value($ret); } return $ret[0]; } function genCSS( $output ){ $len = count($this->value); for($i = 0; $i < $len; $i++ ){ $this->value[$i]->genCSS( $output ); if( $i+1 < $len ){ $output->add( Less_Environment::$_outputMap[','] ); } } } } class Less_Tree_Variable extends Less_Tree{ public $name; public $index; public $currentFileInfo; public $evaluating = false; public $type = 'Variable'; public function __construct($name, $index = null, $currentFileInfo = null) { $this->name = $name; $this->index = $index; $this->currentFileInfo = $currentFileInfo; } public function compile($env) { if( $this->name[1] === '@' ){ $v = new Less_Tree_Variable(substr($this->name, 1), $this->index + 1, $this->currentFileInfo); $name = '@' . $v->compile($env)->value; }else{ $name = $this->name; } if ($this->evaluating) { throw new Less_Exception_Compiler("Recursive variable definition for " . $name, null, $this->index, $this->currentFileInfo); } $this->evaluating = true; foreach($env->frames as $frame){ if( $v = $frame->variable($name) ){ $r = $v->value->compile($env); $this->evaluating = false; return $r; } } throw new Less_Exception_Compiler("variable " . $name . " is undefined in file ".$this->currentFileInfo["filename"], null, $this->index, $this->currentFileInfo); } } class Less_Tree_Mixin_Call extends Less_Tree{ public $selector; public $arguments; public $index; public $currentFileInfo; public $important; public $type = 'MixinCall'; public function __construct($elements, $args, $index, $currentFileInfo, $important = false){ $this->selector = new Less_Tree_Selector($elements); $this->arguments = $args; $this->index = $index; $this->currentFileInfo = $currentFileInfo; $this->important = $important; } public function compile($env){ $rules = array(); $match = false; $isOneFound = false; $candidates = array(); $defaultUsed = false; $conditionResult = array(); $args = array(); foreach($this->arguments as $a){ $args[] = array('name'=> $a['name'], 'value' => $a['value']->compile($env) ); } foreach($env->frames as $frame){ $mixins = $frame->find($this->selector); if( !$mixins ){ continue; } $isOneFound = true; $defNone = 0; $defTrue = 1; $defFalse = 2; $mixins_len = count($mixins); for( $m = 0; $m < $mixins_len; $m++ ){ $mixin = $mixins[$m]; if( $this->IsRecursive( $env, $mixin ) ){ continue; } if( $mixin->matchArgs($args, $env) ){ $candidate = array('mixin' => $mixin, 'group' => $defNone); if( $mixin instanceof Less_Tree_Ruleset ){ for( $f = 0; $f < 2; $f++ ){ Less_Tree_DefaultFunc::value($f); $conditionResult[$f] = $mixin->matchCondition( $args, $env); } if( $conditionResult[0] || $conditionResult[1] ){ if( $conditionResult[0] != $conditionResult[1] ){ $candidate['group'] = $conditionResult[1] ? $defTrue : $defFalse; } $candidates[] = $candidate; } }else{ $candidates[] = $candidate; } $match = true; } } Less_Tree_DefaultFunc::reset(); $count = array(0, 0, 0); for( $m = 0; $m < count($candidates); $m++ ){ $count[ $candidates[$m]['group'] ]++; } if( $count[$defNone] > 0 ){ $defaultResult = $defFalse; } else { $defaultResult = $defTrue; if( ($count[$defTrue] + $count[$defFalse]) > 1 ){ throw new Exception( 'Ambiguous use of `default()` found when matching for `' . $this->format($args) . '`' ); } } $candidates_length = count($candidates); $length_1 = ($candidates_length == 1); for( $m = 0; $m < $candidates_length; $m++){ $candidate = $candidates[$m]['group']; if( ($candidate === $defNone) || ($candidate === $defaultResult) ){ try{ $mixin = $candidates[$m]['mixin']; if( !($mixin instanceof Less_Tree_Mixin_Definition) ){ $mixin = new Less_Tree_Mixin_Definition('', array(), $mixin->rules, null, false); $mixin->originalRuleset = $mixins[$m]->originalRuleset; } $rules = array_merge($rules, $mixin->evalCall($env, $args, $this->important)->rules); } catch (Exception $e) { throw new Less_Exception_Compiler($e->getMessage(), null, null, $this->currentFileInfo); } } } if( $match ){ if( !$this->currentFileInfo || !isset($this->currentFileInfo['reference']) || !$this->currentFileInfo['reference'] ){ Less_Tree::ReferencedArray($rules); } return $rules; } } if( $isOneFound ){ throw new Less_Exception_Compiler('No matching definition was found for `'.$this->Format( $args ).'`', null, $this->index, $this->currentFileInfo); }else{ throw new Less_Exception_Compiler(trim($this->selector->toCSS()) . " is undefined in ".$this->currentFileInfo['filename'], null, $this->index); } } private function Format($args){ $message = array(); if( $args ){ foreach($args as $a){ $argValue = ''; if( $a['name'] ){ $argValue .= $a['name'] . ':'; } if( is_object($a['value']) ){ $argValue .= $a['value']->toCSS(); }else{ $argValue .= '???'; } $message[] = $argValue; } } return implode(', ',$message); } private function IsRecursive( $env, $mixin ){ foreach($env->frames as $recur_frame){ if( !($mixin instanceof Less_Tree_Mixin_Definition) ){ if( $mixin === $recur_frame ){ return true; } if( isset($recur_frame->originalRuleset) && $mixin->ruleset_id === $recur_frame->originalRuleset ){ return true; } } } return false; } } class Less_Tree_Mixin_Definition extends Less_Tree_Ruleset{ public $name; public $selectors; public $params; public $arity = 0; public $rules; public $lookups = array(); public $required = 0; public $frames = array(); public $condition; public $variadic; public $type = 'MixinDefinition'; public function __construct($name, $params, $rules, $condition, $variadic = false, $frames = array() ){ $this->name = $name; $this->selectors = array(new Less_Tree_Selector(array( new Less_Tree_Element(null, $name)))); $this->params = $params; $this->condition = $condition; $this->variadic = $variadic; $this->rules = $rules; if( $params ){ $this->arity = count($params); foreach( $params as $p ){ if (! isset($p['name']) || ($p['name'] && !isset($p['value']))) { $this->required++; } } } $this->frames = $frames; $this->SetRulesetIndex(); } public function toCSS(){ return ''; } public function compileParams($env, $mixinFrames, $args = array() , &$evaldArguments = array() ){ $frame = new Less_Tree_Ruleset(null, array()); $params = $this->params; $mixinEnv = null; $argsLength = 0; if( $args ){ $argsLength = count($args); for($i = 0; $i < $argsLength; $i++ ){ $arg = $args[$i]; if( $arg && $arg['name'] ){ $isNamedFound = false; foreach($params as $j => $param){ if( !isset($evaldArguments[$j]) && $arg['name'] === $params[$j]['name']) { $evaldArguments[$j] = $arg['value']->compile($env); array_unshift($frame->rules, new Less_Tree_Rule( $arg['name'], $arg['value']->compile($env) ) ); $isNamedFound = true; break; } } if ($isNamedFound) { array_splice($args, $i, 1); $i--; $argsLength--; continue; } else { throw new Less_Exception_Compiler("Named argument for " . $this->name .' '.$args[$i]['name'] . ' not found'); } } } } $argIndex = 0; foreach($params as $i => $param){ if ( isset($evaldArguments[$i]) ){ continue; } $arg = null; if( isset($args[$argIndex]) ){ $arg = $args[$argIndex]; } if (isset($param['name']) && $param['name']) { if( isset($param['variadic']) ){ $varargs = array(); for ($j = $argIndex; $j < $argsLength; $j++) { $varargs[] = $args[$j]['value']->compile($env); } $expression = new Less_Tree_Expression($varargs); array_unshift($frame->rules, new Less_Tree_Rule($param['name'], $expression->compile($env))); }else{ $val = ($arg && $arg['value']) ? $arg['value'] : false; if ($val) { $val = $val->compile($env); } else if ( isset($param['value']) ) { if( !$mixinEnv ){ $mixinEnv = new Less_Environment(); $mixinEnv->frames = array_merge( array($frame), $mixinFrames); } $val = $param['value']->compile($mixinEnv); $frame->resetCache(); } else { throw new Less_Exception_Compiler("Wrong number of arguments for " . $this->name . " (" . $argsLength . ' for ' . $this->arity . ")"); } array_unshift($frame->rules, new Less_Tree_Rule($param['name'], $val)); $evaldArguments[$i] = $val; } } if ( isset($param['variadic']) && $args) { for ($j = $argIndex; $j < $argsLength; $j++) { $evaldArguments[$j] = $args[$j]['value']->compile($env); } } $argIndex++; } ksort($evaldArguments); $evaldArguments = array_values($evaldArguments); return $frame; } public function compile($env) { if( $this->frames ){ return new Less_Tree_Mixin_Definition($this->name, $this->params, $this->rules, $this->condition, $this->variadic, $this->frames ); } return new Less_Tree_Mixin_Definition($this->name, $this->params, $this->rules, $this->condition, $this->variadic, $env->frames ); } public function evalCall($env, $args = NULL, $important = NULL) { Less_Environment::$mixin_stack++; $_arguments = array(); if( $this->frames ){ $mixinFrames = array_merge($this->frames, $env->frames); }else{ $mixinFrames = $env->frames; } $frame = $this->compileParams($env, $mixinFrames, $args, $_arguments); $ex = new Less_Tree_Expression($_arguments); array_unshift($frame->rules, new Less_Tree_Rule('@arguments', $ex->compile($env))); $ruleset = new Less_Tree_Ruleset(null, $this->rules); $ruleset->originalRuleset = $this->ruleset_id; $ruleSetEnv = new Less_Environment(); $ruleSetEnv->frames = array_merge( array($this, $frame), $mixinFrames ); $ruleset = $ruleset->compile( $ruleSetEnv ); if( $important ){ $ruleset = $ruleset->makeImportant(); } Less_Environment::$mixin_stack--; return $ruleset; } public function matchCondition($args, $env) { if( !$this->condition ){ return true; } if(!is_array($this->frames)) { $this->frames = array(); } $frame = $this->compileParams($env, array_merge($this->frames,$env->frames), $args ); $compile_env = new Less_Environment(); $compile_env->frames = array_merge( array($frame) , $this->frames , $env->frames ); $compile_env->functions = $env->functions; return (bool)$this->condition->compile($compile_env); } public function matchArgs($args, $env = NULL){ $argsLength = count($args); if( !$this->variadic ){ if( $argsLength < $this->required ){ return false; } if( $argsLength > count($this->params) ){ return false; } }else{ if( $argsLength < ($this->required - 1)){ return false; } } $len = min($argsLength, $this->arity); for( $i = 0; $i < $len; $i++ ){ if( !isset($this->params[$i]['name']) && !isset($this->params[$i]['variadic']) ){ if( $args[$i]['value']->compile($env)->toCSS() != $this->params[$i]['value']->compile($env)->toCSS() ){ return false; } } } return true; } } class Less_Visitor_extendFinder extends Less_Visitor{ public $contexts = array(); public $allExtendsStack; public $foundExtends; public function __construct(){ $this->contexts = array(); $this->allExtendsStack = array(array()); parent::__construct(); } public function run($root){ $root = $this->visitObj($root); $root->allExtends =& $this->allExtendsStack[0]; return $root; } public function visitRule($ruleNode, &$visitDeeper ){ $visitDeeper = false; } public function visitMixinDefinition( $mixinDefinitionNode, &$visitDeeper ){ $visitDeeper = false; } public function visitRuleset($rulesetNode){ if( $rulesetNode->root ){ return; } $allSelectorsExtendList = array(); if( $rulesetNode->rules ){ foreach($rulesetNode->rules as $rule){ if( $rule instanceof Less_Tree_Extend ){ $allSelectorsExtendList[] = $rule; $rulesetNode->extendOnEveryPath = true; } } } foreach($rulesetNode->paths as $selectorPath){ $selector = end($selectorPath); $j = 0; foreach($selector->extendList as $extend){ $this->allExtendsStackPush($rulesetNode, $selectorPath, $extend, $j); } foreach($allSelectorsExtendList as $extend){ $this->allExtendsStackPush($rulesetNode, $selectorPath, $extend, $j); } } $this->contexts[] = $rulesetNode->selectors; } public function allExtendsStackPush($rulesetNode, $selectorPath, $extend, &$j){ $this->foundExtends = true; $extend = clone $extend; $extend->findSelfSelectors( $selectorPath ); $extend->ruleset = $rulesetNode; if( $j === 0 ){ $extend->firstExtendOnThisSelectorPath = true; } $end_key = count($this->allExtendsStack)-1; $this->allExtendsStack[$end_key][] = $extend; $j++; } public function visitRulesetOut( $rulesetNode ){ if( !is_object($rulesetNode) || !$rulesetNode->root ){ array_pop($this->contexts); } } public function visitMedia( $mediaNode ){ $mediaNode->allExtends = array(); $this->allExtendsStack[] =& $mediaNode->allExtends; } public function visitMediaOut(){ array_pop($this->allExtendsStack); } public function visitDirective( $directiveNode ){ $directiveNode->allExtends = array(); $this->allExtendsStack[] =& $directiveNode->allExtends; } public function visitDirectiveOut(){ array_pop($this->allExtendsStack); } } class Less_Visitor_joinSelector extends Less_Visitor{ public $contexts = array( array() ); public function run( $root ){ return $this->visitObj($root); } public function visitRule( $ruleNode, &$visitDeeper ){ $visitDeeper = false; } public function visitMixinDefinition( $mixinDefinitionNode, &$visitDeeper ){ $visitDeeper = false; } public function visitRuleset( $rulesetNode ){ $paths = array(); if( !$rulesetNode->root ){ $selectors = array(); if( $rulesetNode->selectors && $rulesetNode->selectors ){ foreach($rulesetNode->selectors as $selector){ if( $selector->getIsOutput() ){ $selectors[] = $selector; } } } if( !$selectors ){ $rulesetNode->selectors = null; $rulesetNode->rules = null; }else{ $context = end($this->contexts); $paths = $rulesetNode->joinSelectors( $context, $selectors); } $rulesetNode->paths = $paths; } $this->contexts[] = $paths; } public function visitRulesetOut(){ array_pop($this->contexts); } public function visitMedia($mediaNode) { $context = end($this->contexts); if( !count($context) || (is_object($context[0]) && $context[0]->multiMedia) ){ $mediaNode->rules[0]->root = true; } } } class Less_Visitor_processExtends extends Less_Visitor{ public $allExtendsStack; public function run( $root ){ $extendFinder = new Less_Visitor_extendFinder(); $extendFinder->run( $root ); if( !$extendFinder->foundExtends){ return $root; } $root->allExtends = $this->doExtendChaining( $root->allExtends, $root->allExtends); $this->allExtendsStack = array(); $this->allExtendsStack[] = &$root->allExtends; return $this->visitObj( $root ); } private function doExtendChaining( $extendsList, $extendsListTarget, $iterationCount = 0){ $extendsToAdd = array(); for( $extendIndex = 0, $extendsList_len = count($extendsList); $extendIndex < $extendsList_len; $extendIndex++ ){ for( $targetExtendIndex = 0; $targetExtendIndex < count($extendsListTarget); $targetExtendIndex++ ){ $extend = $extendsList[$extendIndex]; $targetExtend = $extendsListTarget[$targetExtendIndex]; if( in_array($targetExtend->object_id, $extend->parent_ids,true) ){ continue; } $selectorPath = array( $targetExtend->selfSelectors[0] ); $matches = $this->findMatch( $extend, $selectorPath); if( $matches ){ foreach($extend->selfSelectors as $selfSelector ){ $newSelector = $this->extendSelector( $matches, $selectorPath, $selfSelector); $newExtend = new Less_Tree_Extend( $targetExtend->selector, $targetExtend->option, 0); $newExtend->selfSelectors = $newSelector; end($newSelector)->extendList = array($newExtend); $extendsToAdd[] = $newExtend; $newExtend->ruleset = $targetExtend->ruleset; $newExtend->parent_ids = array_merge($newExtend->parent_ids,$targetExtend->parent_ids,$extend->parent_ids); if( $targetExtend->firstExtendOnThisSelectorPath ){ $newExtend->firstExtendOnThisSelectorPath = true; $targetExtend->ruleset->paths[] = $newSelector; } } } } } if( $extendsToAdd ){ if( $iterationCount > 100) { try{ $selectorOne = $extendsToAdd[0]->selfSelectors[0]->toCSS(); $selectorTwo = $extendsToAdd[0]->selector->toCSS(); }catch(Exception $e){ $selectorOne = "{unable to calculate}"; $selectorTwo = "{unable to calculate}"; } throw new Less_Exception_Parser("extend circular reference detected. One of the circular extends is currently:" . $selectorOne . ":extend(" . $selectorTwo . ")"); } $extendsToAdd = $this->doExtendChaining( $extendsToAdd, $extendsListTarget, $iterationCount+1); } return array_merge($extendsList, $extendsToAdd); } protected function visitRule( $ruleNode, &$visitDeeper ){ $visitDeeper = false; } protected function visitMixinDefinition( $mixinDefinitionNode, &$visitDeeper ){ $visitDeeper = false; } protected function visitSelector( $selectorNode, &$visitDeeper ){ $visitDeeper = false; } protected function visitRuleset($rulesetNode){ if( $rulesetNode->root ){ return; } $allExtends = end($this->allExtendsStack); $paths_len = count($rulesetNode->paths); foreach($allExtends as $allExtend){ for($pathIndex = 0; $pathIndex < $paths_len; $pathIndex++ ){ if( isset($rulesetNode->extendOnEveryPath) && $rulesetNode->extendOnEveryPath ){ continue; } $selectorPath = $rulesetNode->paths[$pathIndex]; if( end($selectorPath)->extendList ){ continue; } $this->ExtendMatch( $rulesetNode, $allExtend, $selectorPath); } } } private function ExtendMatch( $rulesetNode, $extend, $selectorPath ){ $matches = $this->findMatch($extend, $selectorPath); if( $matches ){ foreach($extend->selfSelectors as $selfSelector ){ $rulesetNode->paths[] = $this->extendSelector($matches, $selectorPath, $selfSelector); } } } private function findMatch($extend, $haystackSelectorPath ){ if( !$this->HasMatches($extend, $haystackSelectorPath) ){ return false; } $needleElements = $extend->selector->elements; $potentialMatches = array(); $potentialMatches_len = 0; $potentialMatch = null; $matches = array(); $haystack_path_len = count($haystackSelectorPath); for($haystackSelectorIndex = 0; $haystackSelectorIndex < $haystack_path_len; $haystackSelectorIndex++ ){ $hackstackSelector = $haystackSelectorPath[$haystackSelectorIndex]; $haystack_elements_len = count($hackstackSelector->elements); for($hackstackElementIndex = 0; $hackstackElementIndex < $haystack_elements_len; $hackstackElementIndex++ ){ $haystackElement = $hackstackSelector->elements[$hackstackElementIndex]; if( $extend->allowBefore || ($haystackSelectorIndex === 0 && $hackstackElementIndex === 0) ){ $potentialMatches[] = array('pathIndex'=> $haystackSelectorIndex, 'index'=> $hackstackElementIndex, 'matched'=> 0, 'initialCombinator'=> $haystackElement->combinator); $potentialMatches_len++; } for($i = 0; $i < $potentialMatches_len; $i++ ){ $potentialMatch = &$potentialMatches[$i]; $potentialMatch = $this->PotentialMatch( $potentialMatch, $needleElements, $haystackElement, $hackstackElementIndex ); if( $potentialMatch && $potentialMatch['matched'] === $extend->selector->elements_len ){ $potentialMatch['finished'] = true; if( !$extend->allowAfter && ($hackstackElementIndex+1 < $haystack_elements_len || $haystackSelectorIndex+1 < $haystack_path_len) ){ $potentialMatch = null; } } if( $potentialMatch ){ if( $potentialMatch['finished'] ){ $potentialMatch['length'] = $extend->selector->elements_len; $potentialMatch['endPathIndex'] = $haystackSelectorIndex; $potentialMatch['endPathElementIndex'] = $hackstackElementIndex + 1; $potentialMatches = array(); $potentialMatches_len = 0; $matches[] = $potentialMatch; } continue; } array_splice($potentialMatches, $i, 1); $potentialMatches_len--; $i--; } } } return $matches; } private function HasMatches($extend, $haystackSelectorPath){ if( !$extend->selector->cacheable ){ return true; } $first_el = $extend->selector->_oelements[0]; foreach($haystackSelectorPath as $hackstackSelector){ if( !$hackstackSelector->cacheable ){ return true; } if( in_array($first_el, $hackstackSelector->_oelements) ){ return true; } } return false; } private function PotentialMatch( $potentialMatch, $needleElements, $haystackElement, $hackstackElementIndex ){ if( $potentialMatch['matched'] > 0 ){ $targetCombinator = $haystackElement->combinator; if( $targetCombinator === '' && $hackstackElementIndex === 0 ){ $targetCombinator = ' '; } if( $needleElements[ $potentialMatch['matched'] ]->combinator !== $targetCombinator ){ return null; } } if( !$this->isElementValuesEqual( $needleElements[$potentialMatch['matched'] ]->value, $haystackElement->value) ){ return null; } $potentialMatch['finished'] = false; $potentialMatch['matched']++; return $potentialMatch; } private function isElementValuesEqual( $elementValue1, $elementValue2 ){ if( $elementValue1 === $elementValue2 ){ return true; } if( is_string($elementValue1) || is_string($elementValue2) ) { return false; } if( $elementValue1 instanceof Less_Tree_Attribute ){ return $this->isAttributeValuesEqual( $elementValue1, $elementValue2 ); } $elementValue1 = $elementValue1->value; if( $elementValue1 instanceof Less_Tree_Selector ){ return $this->isSelectorValuesEqual( $elementValue1, $elementValue2 ); } return false; } private function isSelectorValuesEqual( $elementValue1, $elementValue2 ){ $elementValue2 = $elementValue2->value; if( !($elementValue2 instanceof Less_Tree_Selector) || $elementValue1->elements_len !== $elementValue2->elements_len ){ return false; } for( $i = 0; $i < $elementValue1->elements_len; $i++ ){ if( $elementValue1->elements[$i]->combinator !== $elementValue2->elements[$i]->combinator ){ if( $i !== 0 || ($elementValue1->elements[$i]->combinator || ' ') !== ($elementValue2->elements[$i]->combinator || ' ') ){ return false; } } if( !$this->isElementValuesEqual($elementValue1->elements[$i]->value, $elementValue2->elements[$i]->value) ){ return false; } } return true; } private function isAttributeValuesEqual( $elementValue1, $elementValue2 ){ if( $elementValue1->op !== $elementValue2->op || $elementValue1->key !== $elementValue2->key ){ return false; } if( !$elementValue1->value || !$elementValue2->value ){ if( $elementValue1->value || $elementValue2->value ) { return false; } return true; } $elementValue1 = ($elementValue1->value->value ? $elementValue1->value->value : $elementValue1->value ); $elementValue2 = ($elementValue2->value->value ? $elementValue2->value->value : $elementValue2->value ); return $elementValue1 === $elementValue2; } private function extendSelector($matches, $selectorPath, $replacementSelector){ $currentSelectorPathIndex = 0; $currentSelectorPathElementIndex = 0; $path = array(); $selectorPath_len = count($selectorPath); for($matchIndex = 0, $matches_len = count($matches); $matchIndex < $matches_len; $matchIndex++ ){ $match = $matches[$matchIndex]; $selector = $selectorPath[ $match['pathIndex'] ]; $firstElement = new Less_Tree_Element( $match['initialCombinator'], $replacementSelector->elements[0]->value, $replacementSelector->elements[0]->index, $replacementSelector->elements[0]->currentFileInfo ); if( $match['pathIndex'] > $currentSelectorPathIndex && $currentSelectorPathElementIndex > 0 ){ $last_path = end($path); $last_path->elements = array_merge( $last_path->elements, array_slice( $selectorPath[$currentSelectorPathIndex]->elements, $currentSelectorPathElementIndex)); $currentSelectorPathElementIndex = 0; $currentSelectorPathIndex++; } $newElements = array_merge( array_slice($selector->elements, $currentSelectorPathElementIndex, ($match['index'] - $currentSelectorPathElementIndex) ) , array($firstElement) , array_slice($replacementSelector->elements,1) ); if( $currentSelectorPathIndex === $match['pathIndex'] && $matchIndex > 0 ){ $last_key = count($path)-1; $path[$last_key]->elements = array_merge($path[$last_key]->elements,$newElements); }else{ $path = array_merge( $path, array_slice( $selectorPath, $currentSelectorPathIndex, $match['pathIndex'] )); $path[] = new Less_Tree_Selector( $newElements ); } $currentSelectorPathIndex = $match['endPathIndex']; $currentSelectorPathElementIndex = $match['endPathElementIndex']; if( $currentSelectorPathElementIndex >= count($selectorPath[$currentSelectorPathIndex]->elements) ){ $currentSelectorPathElementIndex = 0; $currentSelectorPathIndex++; } } if( $currentSelectorPathIndex < $selectorPath_len && $currentSelectorPathElementIndex > 0 ){ $last_path = end($path); $last_path->elements = array_merge( $last_path->elements, array_slice($selectorPath[$currentSelectorPathIndex]->elements, $currentSelectorPathElementIndex)); $currentSelectorPathIndex++; } $slice_len = $selectorPath_len - $currentSelectorPathIndex; $path = array_merge($path, array_slice($selectorPath, $currentSelectorPathIndex, $slice_len)); return $path; } protected function visitMedia( $mediaNode ){ $newAllExtends = array_merge( $mediaNode->allExtends, end($this->allExtendsStack) ); $this->allExtendsStack[] = $this->doExtendChaining($newAllExtends, $mediaNode->allExtends); } protected function visitMediaOut(){ array_pop( $this->allExtendsStack ); } protected function visitDirective( $directiveNode ){ $newAllExtends = array_merge( $directiveNode->allExtends, end($this->allExtendsStack) ); $this->allExtendsStack[] = $this->doExtendChaining($newAllExtends, $directiveNode->allExtends); } protected function visitDirectiveOut(){ array_pop($this->allExtendsStack); } } class Less_Visitor_toCSS extends Less_VisitorReplacing{ private $charset; public function __construct(){ parent::__construct(); } public function run( $root ){ return $this->visitObj($root); } public function visitRule( $ruleNode ){ if( $ruleNode->variable ){ return array(); } return $ruleNode; } public function visitMixinDefinition($mixinNode){ $mixinNode->frames = array(); return array(); } public function visitExtend(){ return array(); } public function visitComment( $commentNode ){ if( $commentNode->isSilent() ){ return array(); } return $commentNode; } public function visitMedia( $mediaNode, &$visitDeeper ){ $mediaNode->accept($this); $visitDeeper = false; if( !$mediaNode->rules ){ return array(); } return $mediaNode; } public function visitDirective( $directiveNode ){ if( isset($directiveNode->currentFileInfo['reference']) && (!property_exists($directiveNode,'isReferenced') || !$directiveNode->isReferenced) ){ return array(); } if( $directiveNode->name === '@charset' ){ if( isset($this->charset) && $this->charset ){ return array(); } $this->charset = true; } return $directiveNode; } public function checkPropertiesInRoot( $rulesetNode ){ if( !$rulesetNode->firstRoot ){ return; } foreach($rulesetNode->rules as $ruleNode){ if( $ruleNode instanceof Less_Tree_Rule && !$ruleNode->variable ){ $msg = "properties must be inside selector blocks, they cannot be in the root. Index ".$ruleNode->index.($ruleNode->currentFileInfo ? (' Filename: '.$ruleNode->currentFileInfo['filename']) : null); throw new Less_Exception_Compiler($msg); } } } public function visitRuleset( $rulesetNode, &$visitDeeper ){ $visitDeeper = false; $this->checkPropertiesInRoot( $rulesetNode ); if( $rulesetNode->root ){ return $this->visitRulesetRoot( $rulesetNode ); } $rulesets = array(); $rulesetNode->paths = $this->visitRulesetPaths($rulesetNode); $nodeRuleCnt = count($rulesetNode->rules); for( $i = 0; $i < $nodeRuleCnt; ){ $rule = $rulesetNode->rules[$i]; if( property_exists($rule,'rules') ){ $rulesets[] = $this->visitObj($rule); array_splice($rulesetNode->rules,$i,1); $nodeRuleCnt--; continue; } $i++; } if( $nodeRuleCnt > 0 ){ $rulesetNode->accept($this); if( $rulesetNode->rules ){ if( count($rulesetNode->rules) > 1 ){ $this->_mergeRules( $rulesetNode->rules ); $this->_removeDuplicateRules( $rulesetNode->rules ); } if( $rulesetNode->paths ){ array_splice($rulesets,0,0,array($rulesetNode)); } } } if( count($rulesets) === 1 ){ return $rulesets[0]; } return $rulesets; } private function visitRulesetRoot( $rulesetNode ){ $rulesetNode->accept( $this ); if( $rulesetNode->firstRoot || $rulesetNode->rules ){ return $rulesetNode; } return array(); } private function visitRulesetPaths($rulesetNode){ $paths = array(); foreach($rulesetNode->paths as $p){ if( $p[0]->elements[0]->combinator === ' ' ){ $p[0]->elements[0]->combinator = ''; } foreach($p as $pi){ if( $pi->getIsReferenced() && $pi->getIsOutput() ){ $paths[] = $p; break; } } } return $paths; } protected function _removeDuplicateRules( &$rules ){ $ruleCache = array(); for( $i = count($rules)-1; $i >= 0 ; $i-- ){ $rule = $rules[$i]; if( $rule instanceof Less_Tree_Rule || $rule instanceof Less_Tree_NameValue ){ if( !isset($ruleCache[$rule->name]) ){ $ruleCache[$rule->name] = $rule; }else{ $ruleList =& $ruleCache[$rule->name]; if( $ruleList instanceof Less_Tree_Rule || $ruleList instanceof Less_Tree_NameValue ){ $ruleList = $ruleCache[$rule->name] = array( $ruleCache[$rule->name]->toCSS() ); } $ruleCSS = $rule->toCSS(); if( array_search($ruleCSS,$ruleList) !== false ){ array_splice($rules,$i,1); }else{ $ruleList[] = $ruleCSS; } } } } } protected function _mergeRules( &$rules ){ $groups = array(); $rules_len = count($rules); for( $i = 0; $i < $rules_len; $i++ ){ $rule = $rules[$i]; if( ($rule instanceof Less_Tree_Rule) && $rule->merge ){ $key = $rule->name; if( $rule->important ){ $key .= ',!'; } if( !isset($groups[$key]) ){ $groups[$key] = array(); }else{ array_splice($rules, $i--, 1); $rules_len--; } $groups[$key][] = $rule; } } foreach($groups as $parts){ if( count($parts) > 1 ){ $rule = $parts[0]; $spacedGroups = array(); $lastSpacedGroup = array(); $parts_mapped = array(); foreach($parts as $p){ if( $p->merge === '+' ){ if( $lastSpacedGroup ){ $spacedGroups[] = self::toExpression($lastSpacedGroup); } $lastSpacedGroup = array(); } $lastSpacedGroup[] = $p; } $spacedGroups[] = self::toExpression($lastSpacedGroup); $rule->value = self::toValue($spacedGroups); } } } public static function toExpression($values){ $mapped = array(); foreach($values as $p){ $mapped[] = $p->value; } return new Less_Tree_Expression( $mapped ); } public static function toValue($values){ $mapped = array(); foreach($values as $p){ $mapped[] = $p; } return new Less_Tree_Value($mapped); } } class Less_Exception_Parser extends Exception{ public $currentFile; public $index; protected $input; protected $details = array(); public function __construct($message = null, Exception $previous = null, $index = null, $currentFile = null, $code = 0){ if (PHP_VERSION_ID < 50300) { $this->previous = $previous; parent::__construct($message, $code); } else { parent::__construct($message, $code, $previous); } $this->currentFile = $currentFile; $this->index = $index; $this->genMessage(); } protected function getInput(){ if( !$this->input && $this->currentFile && $this->currentFile['filename'] && file_exists($this->currentFile['filename']) ){ $this->input = file_get_contents( $this->currentFile['filename'] ); } } public function genMessage(){ if( $this->currentFile && $this->currentFile['filename'] ){ $this->message .= ' in '.basename($this->currentFile['filename']); } if( $this->index !== null ){ $this->getInput(); if( $this->input ){ $line = self::getLineNumber(); $this->message .= ' on line '.$line.', column '.self::getColumn(); $lines = explode("\n",$this->input); $count = count($lines); $start_line = max(0, $line-3); $last_line = min($count, $start_line+6); $num_len = strlen($last_line); for( $i = $start_line; $i < $last_line; $i++ ){ $this->message .= "\n".str_pad($i+1,$num_len,'0',STR_PAD_LEFT).'| '.$lines[$i]; } } } } public function getLineNumber(){ if( $this->index ){ if (ini_get("mbstring.func_overload")) { return substr_count(substr($this->input, 0, $this->index), "\n") + 1; } else { return substr_count($this->input, "\n", 0, $this->index) + 1; } } return 1; } public function getColumn(){ $part = substr($this->input, 0, $this->index); $pos = strrpos($part,"\n"); return $this->index - $pos; } } class Less_Exception_Chunk extends Less_Exception_Parser{ protected $parserCurrentIndex = 0; protected $emitFrom = 0; protected $input_len; public function __construct($input, Exception $previous = null, $index = null, $currentFile = null, $code = 0){ $this->message = 'ParseError: Unexpected input'; $this->index = $index; $this->currentFile = $currentFile; $this->input = $input; $this->input_len = strlen($input); $this->Chunks(); $this->genMessage(); } protected function Chunks(){ $level = 0; $parenLevel = 0; $lastMultiCommentEndBrace = null; $lastOpening = null; $lastMultiComment = null; $lastParen = null; for( $this->parserCurrentIndex = 0; $this->parserCurrentIndex < $this->input_len; $this->parserCurrentIndex++ ){ $cc = $this->CharCode($this->parserCurrentIndex); if ((($cc >= 97) && ($cc <= 122)) || ($cc < 34)) { continue; } switch ($cc) { case 40: $parenLevel++; $lastParen = $this->parserCurrentIndex; continue; case 41: $parenLevel--; if( $parenLevel < 0 ){ return $this->fail("missing opening `(`"); } continue; case 59: continue; case 123: $level++; $lastOpening = $this->parserCurrentIndex; continue; case 125: $level--; if( $level < 0 ){ return $this->fail("missing opening `{`"); } continue; case 92: if ($this->parserCurrentIndex < $this->input_len - 1) { $this->parserCurrentIndex++; continue; } return $this->fail("unescaped `\\`"); case 34: case 39: case 96: $matched = 0; $currentChunkStartIndex = $this->parserCurrentIndex; for ($this->parserCurrentIndex = $this->parserCurrentIndex + 1; $this->parserCurrentIndex < $this->input_len; $this->parserCurrentIndex++) { $cc2 = $this->CharCode($this->parserCurrentIndex); if ($cc2 > 96) { continue; } if ($cc2 == $cc) { $matched = 1; break; } if ($cc2 == 92) { if ($this->parserCurrentIndex == $this->input_len - 1) { return $this->fail("unescaped `\\`"); } $this->parserCurrentIndex++; } } if ($matched) { continue; } return $this->fail("unmatched `" . chr($cc) . "`", $currentChunkStartIndex); case 47: if ($parenLevel || ($this->parserCurrentIndex == $this->input_len - 1)) { continue; } $cc2 = $this->CharCode($this->parserCurrentIndex+1); if ($cc2 == 47) { for ($this->parserCurrentIndex = $this->parserCurrentIndex + 2; $this->parserCurrentIndex < $this->input_len; $this->parserCurrentIndex++) { $cc2 = $this->CharCode($this->parserCurrentIndex); if (($cc2 <= 13) && (($cc2 == 10) || ($cc2 == 13))) { break; } } } else if ($cc2 == 42) { $lastMultiComment = $currentChunkStartIndex = $this->parserCurrentIndex; for ($this->parserCurrentIndex = $this->parserCurrentIndex + 2; $this->parserCurrentIndex < $this->input_len - 1; $this->parserCurrentIndex++) { $cc2 = $this->CharCode($this->parserCurrentIndex); if ($cc2 == 125) { $lastMultiCommentEndBrace = $this->parserCurrentIndex; } if ($cc2 != 42) { continue; } if ($this->CharCode($this->parserCurrentIndex+1) == 47) { break; } } if ($this->parserCurrentIndex == $this->input_len - 1) { return $this->fail("missing closing `*/`", $currentChunkStartIndex); } } continue; case 42: if (($this->parserCurrentIndex < $this->input_len - 1) && ($this->CharCode($this->parserCurrentIndex+1) == 47)) { return $this->fail("unmatched `/*`"); } continue; } } if( $level !== 0 ){ if( ($lastMultiComment > $lastOpening) && ($lastMultiCommentEndBrace > $lastMultiComment) ){ return $this->fail("missing closing `}` or `*/`", $lastOpening); } else { return $this->fail("missing closing `}`", $lastOpening); } } else if ( $parenLevel !== 0 ){ return $this->fail("missing closing `)`", $lastParen); } } public function CharCode($pos){ return ord($this->input[$pos]); } public function fail( $msg, $index = null ){ if( !$index ){ $this->index = $this->parserCurrentIndex; }else{ $this->index = $index; } $this->message = 'ParseError: '.$msg; } } class Less_Exception_Compiler extends Less_Exception_Parser{ } class Less_Output_Mapped extends Less_Output { protected $generator; protected $lineNumber = 0; protected $column = 0; protected $contentsMap = array(); public function __construct(array $contentsMap, $generator){ $this->contentsMap = $contentsMap; $this->generator = $generator; } public function add($chunk, $fileInfo = null, $index = 0, $mapLines = null){ if( $chunk === '' ){ return; } $sourceLines = array(); $sourceColumns = ' '; if( $fileInfo ){ $url = $fileInfo['currentUri']; if( isset($this->contentsMap[$url]) ){ $inputSource = substr($this->contentsMap[$url], 0, $index); $sourceLines = explode("\n", $inputSource); $sourceColumns = end($sourceLines); }else{ throw new Exception('Filename '.$url.' not in contentsMap'); } } $lines = explode("\n", $chunk); $columns = end($lines); if($fileInfo){ if(!$mapLines){ $this->generator->addMapping( $this->lineNumber + 1, $this->column, count($sourceLines), strlen($sourceColumns), $fileInfo ); }else{ for($i = 0, $count = count($lines); $i < $count; $i++){ $this->generator->addMapping( $this->lineNumber + $i + 1, $i === 0 ? $this->column : 0, count($sourceLines) + $i, $i === 0 ? strlen($sourceColumns) : 0, $fileInfo ); } } } if(count($lines) === 1){ $this->column += strlen($columns); }else{ $this->lineNumber += count($lines) - 1; $this->column = strlen($columns); } parent::add($chunk); } } class Less_SourceMap_Base64VLQ { private $shift = 5; private $mask = 0x1F; private $continuationBit = 0x20; private $charToIntMap = array( 'A' => 0, 'B' => 1, 'C' => 2, 'D' => 3, 'E' => 4, 'F' => 5, 'G' => 6, 'H' => 7,'I' => 8, 'J' => 9, 'K' => 10, 'L' => 11, 'M' => 12, 'N' => 13, 'O' => 14, 'P' => 15, 'Q' => 16, 'R' => 17, 'S' => 18, 'T' => 19, 'U' => 20, 'V' => 21, 'W' => 22, 'X' => 23, 'Y' => 24, 'Z' => 25, 'a' => 26, 'b' => 27, 'c' => 28, 'd' => 29, 'e' => 30, 'f' => 31, 'g' => 32, 'h' => 33, 'i' => 34, 'j' => 35, 'k' => 36, 'l' => 37, 'm' => 38, 'n' => 39, 'o' => 40, 'p' => 41, 'q' => 42, 'r' => 43, 's' => 44, 't' => 45, 'u' => 46, 'v' => 47, 'w' => 48, 'x' => 49, 'y' => 50, 'z' => 51, 0 => 52, 1 => 53, 2 => 54, 3 => 55, 4 => 56, 5 => 57, 6 => 58, 7 => 59, 8 => 60, 9 => 61, '+' => 62, '/' => 63, ); private $intToCharMap = array( 0 => 'A', 1 => 'B', 2 => 'C', 3 => 'D', 4 => 'E', 5 => 'F', 6 => 'G', 7 => 'H', 8 => 'I', 9 => 'J', 10 => 'K', 11 => 'L', 12 => 'M', 13 => 'N', 14 => 'O', 15 => 'P', 16 => 'Q', 17 => 'R', 18 => 'S', 19 => 'T', 20 => 'U', 21 => 'V', 22 => 'W', 23 => 'X', 24 => 'Y', 25 => 'Z', 26 => 'a', 27 => 'b', 28 => 'c', 29 => 'd', 30 => 'e', 31 => 'f', 32 => 'g', 33 => 'h', 34 => 'i', 35 => 'j', 36 => 'k', 37 => 'l', 38 => 'm', 39 => 'n', 40 => 'o', 41 => 'p', 42 => 'q', 43 => 'r', 44 => 's', 45 => 't', 46 => 'u', 47 => 'v', 48 => 'w', 49 => 'x', 50 => 'y', 51 => 'z', 52 => '0', 53 => '1', 54 => '2', 55 => '3', 56 => '4', 57 => '5', 58 => '6', 59 => '7', 60 => '8', 61 => '9', 62 => '+', 63 => '/', ); public function __construct(){ } public function toVLQSigned($aValue){ return 0xffffffff & ($aValue < 0 ? ((-$aValue) << 1) + 1 : ($aValue << 1) + 0); } public function fromVLQSigned($aValue){ return $aValue & 1 ? $this->zeroFill(~$aValue + 2, 1) | (-1 - 0x7fffffff) : $this->zeroFill($aValue, 1); } public function encode($aValue){ $encoded = ''; $vlq = $this->toVLQSigned($aValue); do { $digit = $vlq & $this->mask; $vlq = $this->zeroFill($vlq, $this->shift); if($vlq > 0){ $digit |= $this->continuationBit; } $encoded .= $this->base64Encode($digit); } while($vlq > 0); return $encoded; } public function decode($encoded){ $vlq = 0; $i = 0; do { $digit = $this->base64Decode($encoded[$i]); $vlq |= ($digit & $this->mask) << ($i * $this->shift); $i++; } while($digit & $this->continuationBit); return $this->fromVLQSigned($vlq); } public function zeroFill($a, $b){ return ($a >= 0) ? ($a >> $b) : ($a >> $b) & (PHP_INT_MAX >> ($b - 1)); } public function base64Encode($number){ if($number < 0 || $number > 63){ throw new Exception(sprintf('Invalid number "%s" given. Must be between 0 and 63.', $number)); } return $this->intToCharMap[$number]; } public function base64Decode($char){ if(!array_key_exists($char, $this->charToIntMap)){ throw new Exception(sprintf('Invalid base 64 digit "%s" given.', $char)); } return $this->charToIntMap[$char]; } } class Less_SourceMap_Generator extends Less_Configurable { const VERSION = 3; protected $defaultOptions = array( 'sourceRoot' => '', 'sourceMapFilename' => null, 'sourceMapURL' => null, 'sourceMapWriteTo' => null, 'outputSourceFiles' => false, 'sourceMapRootpath' => '', 'sourceMapBasepath' => '' ); protected $encoder; protected $mappings = array(); protected $root; protected $contentsMap = array(); protected $sources = array(); protected $source_keys = array(); public function __construct(Less_Tree_Ruleset $root, $contentsMap, $options = array()){ $this->root = $root; $this->contentsMap = $contentsMap; $this->encoder = new Less_SourceMap_Base64VLQ(); $this->SetOptions($options); $this->options['sourceMapRootpath'] = $this->fixWindowsPath($this->options['sourceMapRootpath'], true); $this->options['sourceMapBasepath'] = $this->fixWindowsPath($this->options['sourceMapBasepath'], true); } public function generateCSS(){ $output = new Less_Output_Mapped($this->contentsMap, $this); $this->root->genCSS($output); $sourceMapUrl = $this->getOption('sourceMapURL'); $sourceMapFilename = $this->getOption('sourceMapFilename'); $sourceMapContent = $this->generateJson(); $sourceMapWriteTo = $this->getOption('sourceMapWriteTo'); if( !$sourceMapUrl && $sourceMapFilename ){ $sourceMapUrl = $this->normalizeFilename($sourceMapFilename); } if( $sourceMapWriteTo ){ $this->saveMap($sourceMapWriteTo, $sourceMapContent); } if( !$sourceMapUrl ){ $sourceMapUrl = sprintf('data:application/json,%s', Less_Functions::encodeURIComponent($sourceMapContent)); } if( $sourceMapUrl ){ $output->add( sprintf('/*# sourceMappingURL=%s */', $sourceMapUrl) ); } return $output->toString(); } protected function saveMap($file, $content){ $dir = dirname($file); if( !is_dir($dir) ){ throw new Exception(sprintf('The directory "%s" does not exist. Cannot save the source map.', $dir)); } if(file_put_contents($file, $content) === false){ throw new Exception(sprintf('Cannot save the source map to "%s"', $file)); } return true; } protected function normalizeFilename($filename){ $filename = $this->fixWindowsPath($filename); $rootpath = $this->getOption('sourceMapRootpath'); $basePath = $this->getOption('sourceMapBasepath'); if (strpos($filename, $basePath) === 0) { $filename = substr($filename, strlen($basePath)); } if(strpos($filename, '\\') === 0 || strpos($filename, '/') === 0){ $filename = substr($filename, 1); } return $rootpath . $filename; } public function addMapping($generatedLine, $generatedColumn, $originalLine, $originalColumn, $fileInfo ){ $this->mappings[] = array( 'generated_line' => $generatedLine, 'generated_column' => $generatedColumn, 'original_line' => $originalLine, 'original_column' => $originalColumn, 'source_file' => $fileInfo['currentUri'] ); $this->sources[$fileInfo['currentUri']] = $fileInfo['filename']; } protected function generateJson(){ $sourceMap = array(); $mappings = $this->generateMappings(); $sourceMap['version'] = self::VERSION; $file = $this->getOption('sourceMapFilename'); if( $file ){ $sourceMap['file'] = $file; } $root = $this->getOption('sourceRoot'); if( $root ){ $sourceMap['sourceRoot'] = $root; } $sourceMap['sources'] = array(); foreach($this->sources as $source_uri => $source_filename){ $sourceMap['sources'][] = $this->normalizeFilename($source_filename); } $sourceMap['names'] = array(); $sourceMap['mappings'] = $mappings; if( $this->getOption('outputSourceFiles') ){ $sourceMap['sourcesContent'] = $this->getSourcesContent(); } if( count($sourceMap['sources']) && empty($sourceMap['sourceRoot']) ){ unset($sourceMap['sourceRoot']); } return json_encode($sourceMap); } protected function getSourcesContent(){ if(empty($this->sources)){ return; } $content = array(); foreach($this->sources as $sourceFile){ $content[] = file_get_contents($sourceFile); } return $content; } public function generateMappings(){ if( !count($this->mappings) ){ return ''; } $this->source_keys = array_flip(array_keys($this->sources)); $groupedMap = $groupedMapEncoded = array(); foreach($this->mappings as $m){ $groupedMap[$m['generated_line']][] = $m; } ksort($groupedMap); $lastGeneratedLine = $lastOriginalIndex = $lastOriginalLine = $lastOriginalColumn = 0; foreach($groupedMap as $lineNumber => $line_map){ while(++$lastGeneratedLine < $lineNumber){ $groupedMapEncoded[] = ';'; } $lineMapEncoded = array(); $lastGeneratedColumn = 0; foreach($line_map as $m){ $mapEncoded = $this->encoder->encode($m['generated_column'] - $lastGeneratedColumn); $lastGeneratedColumn = $m['generated_column']; if( $m['source_file'] ){ $index = $this->findFileIndex($m['source_file']); if( $index !== false ){ $mapEncoded .= $this->encoder->encode($index - $lastOriginalIndex); $lastOriginalIndex = $index; $mapEncoded .= $this->encoder->encode($m['original_line'] - 1 - $lastOriginalLine); $lastOriginalLine = $m['original_line'] - 1; $mapEncoded .= $this->encoder->encode($m['original_column'] - $lastOriginalColumn); $lastOriginalColumn = $m['original_column']; } } $lineMapEncoded[] = $mapEncoded; } $groupedMapEncoded[] = implode(',', $lineMapEncoded) . ';'; } return rtrim(implode($groupedMapEncoded), ';'); } protected function findFileIndex($filename){ return $this->source_keys[$filename]; } public function fixWindowsPath($path, $addEndSlash = false){ $slash = ($addEndSlash) ? '/' : ''; if( !empty($path) ){ $path = str_replace('\\', '/', $path); $path = rtrim($path,'/') . $slash; } return $path; } }
